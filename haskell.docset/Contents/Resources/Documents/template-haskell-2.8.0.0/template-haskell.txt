-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Facilities for manipulating Haskell source code using Template
--   Haskell.
@package template-haskell


-- | Abstract syntax definitions for Template Haskell.
module Language.Haskell.TH.Syntax
class (Monad m, Applicative m) => Quasi m
qNewName :: Quasi m => String -> m Name
qReport :: Quasi m => Bool -> String -> m ()
qRecover :: Quasi m => m a -> m a -> m a
qLookupName :: Quasi m => Bool -> String -> m (Maybe Name)
qReify :: Quasi m => Name -> m Info
qReifyInstances :: Quasi m => Name -> [Type] -> m [Dec]
qLocation :: Quasi m => m Loc
qRunIO :: Quasi m => IO a -> m a
qAddDependentFile :: Quasi m => FilePath -> m ()
badIO :: String -> IO a
counter :: IORef Int
newtype Q a
Q :: (forall m. Quasi m => m a) -> Q a
unQ :: Q a -> forall m. Quasi m => m a
runQ :: Quasi m => Q a -> m a

-- | Generate a fresh name, which cannot be captured.
--   
--   For example, this:
--   
--   <pre>
--   f = $(do
--     nm1 &lt;- newName "x"
--     let nm2 = <a>mkName</a> "x"
--     return (<a>LamE</a> [<a>VarP</a> nm1] (LamE [VarP nm2] (<a>VarE</a> nm1)))
--    )
--   </pre>
--   
--   will produce the splice
--   
--   <pre>
--   f = \x0 -&gt; \x -&gt; x0
--   </pre>
--   
--   In particular, the occurrence <tt>VarE nm1</tt> refers to the binding
--   <tt>VarP nm1</tt>, and is not captured by the binding <tt>VarP
--   nm2</tt>.
--   
--   Although names generated by <tt>newName</tt> cannot <i>be
--   captured</i>, they can <i>capture</i> other names. For example, this:
--   
--   <pre>
--   g = $(do
--     nm1 &lt;- newName "x"
--     let nm2 = mkName "x"
--     return (LamE [VarP nm2] (LamE [VarP nm1] (VarE nm2)))
--    )
--   </pre>
--   
--   will produce the splice
--   
--   <pre>
--   g = \x -&gt; \x0 -&gt; x0
--   </pre>
--   
--   since the occurrence <tt>VarE nm2</tt> is captured by the innermost
--   binding of <tt>x</tt>, namely <tt>VarP nm1</tt>.
newName :: String -> Q Name

-- | Report an error (True) or warning (False), but carry on; use
--   <a>fail</a> to stop.

-- | <i>Deprecated: Use reportError or reportWarning instead </i>
report :: Bool -> String -> Q ()

-- | Report an error to the user, but allow the current splice's
--   computation to carry on. To abort the computation, use <a>fail</a>.
reportError :: String -> Q ()

-- | Report a warning to the user, and carry on.
reportWarning :: String -> Q ()

-- | Recover from errors raised by <a>reportError</a> or <a>fail</a>.
recover :: Q a -> Q a -> Q a
lookupName :: Bool -> String -> Q (Maybe Name)

-- | Look up the given name in the (type namespace of the) current splice's
--   scope. See <a>Language.Haskell.TH.Syntax#namelookup</a> for more
--   details.
lookupTypeName :: String -> Q (Maybe Name)

-- | Look up the given name in the (value namespace of the) current
--   splice's scope. See <a>Language.Haskell.TH.Syntax#namelookup</a> for
--   more details.
lookupValueName :: String -> Q (Maybe Name)

-- | <a>reify</a> looks up information about the <a>Name</a>.
--   
--   It is sometimes useful to construct the argument name using
--   <a>lookupTypeName</a> or <a>lookupValueName</a> to ensure that we are
--   reifying from the right namespace. For instance, in this context:
--   
--   <pre>
--   data D = D
--   </pre>
--   
--   which <tt>D</tt> does <tt>reify (mkName "D")</tt> return information
--   about? (Answer: <tt>D</tt>-the-type, but don't rely on it.) To ensure
--   we get information about <tt>D</tt>-the-value, use
--   <a>lookupValueName</a>:
--   
--   <pre>
--   do
--     Just nm &lt;- lookupValueName "D"
--     reify nm
--   </pre>
--   
--   and to get information about <tt>D</tt>-the-type, use
--   <a>lookupTypeName</a>.
reify :: Name -> Q Info

-- | <tt>reifyInstances nm tys</tt> returns a list of visible instances of
--   <tt>nm tys</tt>. That is, if <tt>nm</tt> is the name of a type class,
--   then all instances of this class at the types <tt>tys</tt> are
--   returned. Alternatively, if <tt>nm</tt> is the name of a data family
--   or type family, all instances of this family at the types <tt>tys</tt>
--   are returned.
reifyInstances :: Name -> [Type] -> Q [InstanceDec]

-- | Is the list of instances returned by <a>reifyInstances</a> nonempty?
isInstance :: Name -> [Type] -> Q Bool

-- | The location at which this computation is spliced.
location :: Q Loc

-- | The <a>runIO</a> function lets you run an I/O computation in the
--   <a>Q</a> monad. Take care: you are guaranteed the ordering of calls to
--   <a>runIO</a> within a single <a>Q</a> computation, but not about the
--   order in which splices are run.
--   
--   Note: for various murky reasons, stdout and stderr handles are not
--   necesarily flushed when the compiler finishes running, so you should
--   flush them yourself.
runIO :: IO a -> Q a

-- | Record external files that runIO is using (dependent upon). The
--   compiler can then recognize that it should re-compile the file using
--   this TH when the external file changes. Note that ghc -M will still
--   not know about these dependencies - it does not execute TH. Expects an
--   absolute file path.
addDependentFile :: FilePath -> Q ()
returnQ :: a -> Q a
bindQ :: Q a -> (a -> Q b) -> Q b
sequenceQ :: [Q a] -> Q [a]
class Lift t
lift :: Lift t => t -> Q Exp
liftString :: String -> Q Exp
trueName :: Name
falseName :: Name
nothingName :: Name
justName :: Name
leftName :: Name
rightName :: Name
newtype ModName
ModName :: String -> ModName
newtype PkgName
PkgName :: String -> PkgName
newtype OccName
OccName :: String -> OccName
mkModName :: String -> ModName
modString :: ModName -> String
mkPkgName :: String -> PkgName
pkgString :: PkgName -> String
mkOccName :: String -> OccName
occString :: OccName -> String

-- | An abstract type representing names in the syntax tree.
--   
--   <a>Name</a>s can be constructed in several ways, which come with
--   different name-capture guarantees (see
--   <a>Language.Haskell.TH.Syntax#namecapture</a> for an explanation of
--   name capture):
--   
--   <ul>
--   <li>the built-in syntax <tt>'f</tt> and <tt>''T</tt> can be used to
--   construct names, The expression <tt>'f</tt> gives a <tt>Name</tt>
--   which refers to the value <tt>f</tt> currently in scope, and
--   <tt>''T</tt> gives a <tt>Name</tt> which refers to the type <tt>T</tt>
--   currently in scope. These names can never be captured.</li>
--   <li><a>lookupValueName</a> and <a>lookupTypeName</a> are similar to
--   <tt>'f</tt> and <tt>''T</tt> respectively, but the <tt>Name</tt>s are
--   looked up at the point where the current splice is being run. These
--   names can never be captured.</li>
--   <li><a>newName</a> monadically generates a new name, which can never
--   be captured.</li>
--   <li><a>mkName</a> generates a capturable name.</li>
--   </ul>
--   
--   Names constructed using <tt>newName</tt> and <tt>mkName</tt> may be
--   used in bindings (such as <tt>let x = ...</tt> or <tt>x -&gt;
--   ...</tt>), but names constructed using <tt>lookupValueName</tt>,
--   <tt>lookupTypeName</tt>, <tt>'f</tt>, <tt>''T</tt> may not.
data Name
Name :: OccName -> NameFlavour -> Name
data NameFlavour

-- | An unqualified name; dynamically bound
NameS :: NameFlavour

-- | A qualified name; dynamically bound
NameQ :: ModName -> NameFlavour

-- | A unique local name
NameU :: Int# -> NameFlavour

-- | Local name bound outside of the TH AST
NameL :: Int# -> NameFlavour

-- | Global name bound outside of the TH AST: An original name (occurrences
--   only, not binders) Need the namespace too to be sure which thing we
--   are naming
NameG :: NameSpace -> PkgName -> ModName -> NameFlavour
con_NameS :: Constr
con_NameG :: Constr
con_NameL :: Constr
con_NameU :: Constr
con_NameQ :: Constr
ty_NameFlavour :: DataType
data NameSpace

-- | Variables
VarName :: NameSpace

-- | Data constructors
DataName :: NameSpace

-- | Type constructors and classes; Haskell has them in the same name space
--   for now.
TcClsName :: NameSpace
type Uniq = Int

-- | The name without its module prefix
nameBase :: Name -> String

-- | Module prefix of a name, if it exists
nameModule :: Name -> Maybe String

-- | Generate a capturable name. Occurrences of such names will be resolved
--   according to the Haskell scoping rules at the occurrence site.
--   
--   For example:
--   
--   <pre>
--   f = [| pi + $(varE (mkName "pi")) |]
--   ...
--   g = let pi = 3 in $f
--   </pre>
--   
--   In this case, <tt>g</tt> is desugared to
--   
--   <pre>
--   g = Prelude.pi + 3
--   </pre>
--   
--   Note that <tt>mkName</tt> may be used with qualified names:
--   
--   <pre>
--   mkName "Prelude.pi"
--   </pre>
--   
--   See also <a>dyn</a> for a useful combinator. The above example could
--   be rewritten using <tt>dyn</tt> as
--   
--   <pre>
--   f = [| pi + $(dyn "pi") |]
--   </pre>
mkName :: String -> Name

-- | Only used internally
mkNameU :: String -> Uniq -> Name

-- | Only used internally
mkNameL :: String -> Uniq -> Name

-- | Used for 'x etc, but not available to the programmer
mkNameG :: NameSpace -> String -> String -> String -> Name
mkNameG_v :: String -> String -> String -> Name
mkNameG_d :: String -> String -> String -> Name
mkNameG_tc :: String -> String -> String -> Name
data NameIs
Alone :: NameIs
Applied :: NameIs
Infix :: NameIs
showName :: Name -> String
showName' :: NameIs -> Name -> String

-- | Tuple data constructor
tupleDataName :: Int -> Name

-- | Tuple type constructor
tupleTypeName :: Int -> Name
mk_tup_name :: Int -> NameSpace -> Name

-- | Unboxed tuple data constructor
unboxedTupleDataName :: Int -> Name

-- | Unboxed tuple type constructor
unboxedTupleTypeName :: Int -> Name
mk_unboxed_tup_name :: Int -> NameSpace -> Name
data Loc
Loc :: String -> String -> String -> CharPos -> CharPos -> Loc
loc_filename :: Loc -> String
loc_package :: Loc -> String
loc_module :: Loc -> String
loc_start :: Loc -> CharPos
loc_end :: Loc -> CharPos
type CharPos = (Int, Int)

-- | Obtained from <a>reify</a> in the <a>Q</a> Monad.
data Info

-- | A class, with a list of its visible instances
ClassI :: Dec -> [InstanceDec] -> Info

-- | A class method
ClassOpI :: Name -> Type -> ParentName -> Fixity -> Info

-- | A "plain" type constructor. "Fancier" type constructors are returned
--   using <a>PrimTyConI</a> or <a>FamilyI</a> as appropriate
TyConI :: Dec -> Info

-- | A type or data family, with a list of its visible instances
FamilyI :: Dec -> [InstanceDec] -> Info

-- | A "primitive" type constructor, which can't be expressed with a
--   <a>Dec</a>. Examples: <tt>(-&gt;)</tt>, <tt>Int#</tt>.
PrimTyConI :: Name -> Arity -> Unlifted -> Info

-- | A data constructor
DataConI :: Name -> Type -> ParentName -> Fixity -> Info

-- | A "value" variable (as opposed to a type variable, see <a>TyVarI</a>).
--   
--   The <tt>Maybe Dec</tt> field contains <tt>Just</tt> the declaration
--   which defined the variable -- including the RHS of the declaration --
--   or else <tt>Nothing</tt>, in the case where the RHS is unavailable to
--   the compiler. At present, this value is _always_ <tt>Nothing</tt>:
--   returning the RHS has not yet been implemented because of lack of
--   interest.
VarI :: Name -> Type -> (Maybe Dec) -> Fixity -> Info

-- | A type variable.
--   
--   The <tt>Type</tt> field contains the type which underlies the
--   variable. At present, this is always <tt><a>VarT</a> theName</tt>, but
--   future changes may permit refinement of this.
TyVarI :: Name -> Type -> Info

-- | In <a>ClassOpI</a> and <a>DataConI</a>, name of the parent class or
--   type
type ParentName = Name

-- | In <a>PrimTyConI</a>, arity of the type constructor
type Arity = Int

-- | In <a>PrimTyConI</a>, is the type constructor unlifted?
type Unlifted = Bool

-- | <a>InstanceDec</a> desribes a single instance of a class or type
--   function. It is just a <a>Dec</a>, but guaranteed to be one of the
--   following:
--   
--   <ul>
--   <li><a>InstanceD</a> (with empty <tt>[<a>Dec</a>]</tt>)</li>
--   <li><a>DataInstD</a> or <a>NewtypeInstD</a> (with empty derived
--   <tt>[<a>Name</a>]</tt>)</li>
--   <li><a>TySynInstD</a></li>
--   </ul>
type InstanceDec = Dec
data Fixity
Fixity :: Int -> FixityDirection -> Fixity
data FixityDirection
InfixL :: FixityDirection
InfixR :: FixityDirection
InfixN :: FixityDirection

-- | Highest allowed operator precedence for <a>Fixity</a> constructor
--   (answer: 9)
maxPrecedence :: Int

-- | Default fixity: <tt>infixl 9</tt>
defaultFixity :: Fixity
data Lit
CharL :: Char -> Lit
StringL :: String -> Lit

-- | Used for overloaded and non-overloaded literals. We don't have a good
--   way to represent non-overloaded literals at the moment. Maybe that
--   doesn't matter?
IntegerL :: Integer -> Lit
RationalL :: Rational -> Lit
IntPrimL :: Integer -> Lit
WordPrimL :: Integer -> Lit
FloatPrimL :: Rational -> Lit
DoublePrimL :: Rational -> Lit

-- | A primitive C-style string, type Addr#
StringPrimL :: [Word8] -> Lit

-- | Pattern in Haskell given in <tt>{}</tt>
data Pat

-- | <pre>
--   { 5 or <tt>c</tt> }
--   </pre>
LitP :: Lit -> Pat

-- | <pre>
--   { x }
--   </pre>
VarP :: Name -> Pat

-- | <pre>
--   { (p1,p2) }
--   </pre>
TupP :: [Pat] -> Pat

-- | <pre>
--   { () }
--   </pre>
UnboxedTupP :: [Pat] -> Pat

-- | <pre>
--   data T1 = C1 t1 t2; {C1 p1 p1} = e
--   </pre>
ConP :: Name -> [Pat] -> Pat

-- | <pre>
--   foo ({x :+ y}) = e
--   </pre>
InfixP :: Pat -> Name -> Pat -> Pat

-- | <pre>
--   foo ({x :+ y}) = e
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
UInfixP :: Pat -> Name -> Pat -> Pat

-- | <pre>
--   {(p)}
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
ParensP :: Pat -> Pat

-- | <pre>
--   { ~p }
--   </pre>
TildeP :: Pat -> Pat

-- | <pre>
--   { !p }
--   </pre>
BangP :: Pat -> Pat

-- | <pre>
--   { x @ p }
--   </pre>
AsP :: Name -> Pat -> Pat

-- | <pre>
--   { _ }
--   </pre>
WildP :: Pat

-- | <pre>
--   f (Pt { pointx = x }) = g x
--   </pre>
RecP :: Name -> [FieldPat] -> Pat

-- | <pre>
--   { [1,2,3] }
--   </pre>
ListP :: [Pat] -> Pat

-- | <pre>
--   { p :: t }
--   </pre>
SigP :: Pat -> Type -> Pat

-- | <pre>
--   { e -&gt; p }
--   </pre>
ViewP :: Exp -> Pat -> Pat
type FieldPat = (Name, Pat)
data Match

-- | <pre>
--   case e of { pat -&gt; body where decs }
--   </pre>
Match :: Pat -> Body -> [Dec] -> Match
data Clause

-- | <pre>
--   f { p1 p2 = body where decs }
--   </pre>
Clause :: [Pat] -> Body -> [Dec] -> Clause
data Exp

-- | <pre>
--   { x }
--   </pre>
VarE :: Name -> Exp

-- | <pre>
--   data T1 = C1 t1 t2; p = {C1} e1 e2
--   </pre>
ConE :: Name -> Exp

-- | <pre>
--   { 5 or <tt>c</tt>}
--   </pre>
LitE :: Lit -> Exp

-- | <pre>
--   { f x }
--   </pre>
AppE :: Exp -> Exp -> Exp

-- | <pre>
--   {x + y} or {(x+)} or {(+ x)} or {(+)}
--   </pre>
InfixE :: (Maybe Exp) -> Exp -> (Maybe Exp) -> Exp

-- | <pre>
--   {x + y}
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
UInfixE :: Exp -> Exp -> Exp -> Exp

-- | <pre>
--   { (e) }
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
ParensE :: Exp -> Exp

-- | <pre>
--   {  p1 p2 -&gt; e }
--   </pre>
LamE :: [Pat] -> Exp -> Exp

-- | <pre>
--   { case m1; m2 }
--   </pre>
LamCaseE :: [Match] -> Exp

-- | <pre>
--   { (e1,e2) }
--   </pre>
TupE :: [Exp] -> Exp

-- | <pre>
--   { () }
--   </pre>
UnboxedTupE :: [Exp] -> Exp

-- | <pre>
--   { if e1 then e2 else e3 }
--   </pre>
CondE :: Exp -> Exp -> Exp -> Exp

-- | <pre>
--   { if | g1 -&gt; e1 | g2 -&gt; e2 }
--   </pre>
MultiIfE :: [(Guard, Exp)] -> Exp

-- | <pre>
--   { let x=e1;   y=e2 in e3 }
--   </pre>
LetE :: [Dec] -> Exp -> Exp

-- | <pre>
--   { case e of m1; m2 }
--   </pre>
CaseE :: Exp -> [Match] -> Exp

-- | <pre>
--   { do { p &lt;- e1; e2 }  }
--   </pre>
DoE :: [Stmt] -> Exp

-- | <pre>
--   { [ (x,y) | x &lt;- xs, y &lt;- ys ] }
--   </pre>
--   
--   The result expression of the comprehension is the <i>last</i> of the
--   <tt><a>Stmt</a></tt>s, and should be a <a>NoBindS</a>.
--   
--   E.g. translation:
--   
--   <pre>
--   [ f x | x &lt;- xs ]
--   </pre>
--   
--   <pre>
--   CompE [BindS (VarP x) (VarE xs), NoBindS (AppE (VarE f) (VarE x))]
--   </pre>
CompE :: [Stmt] -> Exp

-- | <pre>
--   { [ 1 ,2 .. 10 ] }
--   </pre>
ArithSeqE :: Range -> Exp

-- | <pre>
--   { [1,2,3] }
--   </pre>
ListE :: [Exp] -> Exp

-- | <pre>
--   { e :: t }
--   </pre>
SigE :: Exp -> Type -> Exp

-- | <pre>
--   { T { x = y, z = w } }
--   </pre>
RecConE :: Name -> [FieldExp] -> Exp

-- | <pre>
--   { (f x) { z = w } }
--   </pre>
RecUpdE :: Exp -> [FieldExp] -> Exp
type FieldExp = (Name, Exp)
data Body

-- | <pre>
--   f p { | e1 = e2 
--         | e3 = e4 } 
--    where ds
--   </pre>
GuardedB :: [(Guard, Exp)] -> Body

-- | <pre>
--   f p { = e } where ds
--   </pre>
NormalB :: Exp -> Body
data Guard

-- | <pre>
--   f x { | odd x } = x
--   </pre>
NormalG :: Exp -> Guard

-- | <pre>
--   f x { | Just y &lt;- x, Just z &lt;- y } = z
--   </pre>
PatG :: [Stmt] -> Guard
data Stmt
BindS :: Pat -> Exp -> Stmt
LetS :: [Dec] -> Stmt
NoBindS :: Exp -> Stmt
ParS :: [[Stmt]] -> Stmt
data Range
FromR :: Exp -> Range
FromThenR :: Exp -> Exp -> Range
FromToR :: Exp -> Exp -> Range
FromThenToR :: Exp -> Exp -> Exp -> Range
data Dec

-- | <pre>
--   { f p1 p2 = b where decs }
--   </pre>
FunD :: Name -> [Clause] -> Dec

-- | <pre>
--   { p = b where decs }
--   </pre>
ValD :: Pat -> Body -> [Dec] -> Dec

-- | <pre>
--   { data Cxt x =&gt; T x = A x | B (T x)
--          deriving (Z,W)}
--   </pre>
DataD :: Cxt -> Name -> [TyVarBndr] -> [Con] -> [Name] -> Dec

-- | <pre>
--   { newtype Cxt x =&gt; T x = A (B x)
--          deriving (Z,W)}
--   </pre>
NewtypeD :: Cxt -> Name -> [TyVarBndr] -> Con -> [Name] -> Dec

-- | <pre>
--   { type T x = (x,x) }
--   </pre>
TySynD :: Name -> [TyVarBndr] -> Type -> Dec

-- | <pre>
--   { class Eq a =&gt; Ord a where ds }
--   </pre>
ClassD :: Cxt -> Name -> [TyVarBndr] -> [FunDep] -> [Dec] -> Dec

-- | <pre>
--   { instance Show w =&gt; Show [w]
--          where ds }
--   </pre>
InstanceD :: Cxt -> Type -> [Dec] -> Dec

-- | <pre>
--   { length :: [a] -&gt; Int }
--   </pre>
SigD :: Name -> Type -> Dec

-- | <pre>
--   { foreign import ... }
--   { foreign export ... }
--   </pre>
ForeignD :: Foreign -> Dec

-- | <pre>
--   { infix 3 foo }
--   </pre>
InfixD :: Fixity -> Name -> Dec

-- | <pre>
--   { {--} }
--   </pre>
PragmaD :: Pragma -> Dec

-- | <pre>
--   { type family T a b c :: * }
--   </pre>
FamilyD :: FamFlavour -> Name -> [TyVarBndr] -> (Maybe Kind) -> Dec

-- | <pre>
--   { data instance Cxt x =&gt; T [x] = A x 
--                                   | B (T x)
--          deriving (Z,W)}
--   </pre>
DataInstD :: Cxt -> Name -> [Type] -> [Con] -> [Name] -> Dec

-- | <pre>
--   { newtype instance Cxt x =&gt; T [x] = A (B x)
--          deriving (Z,W)}
--   </pre>
NewtypeInstD :: Cxt -> Name -> [Type] -> Con -> [Name] -> Dec

-- | <pre>
--   { type instance T (Maybe x) = (x,x) }
--   </pre>
TySynInstD :: Name -> [Type] -> Type -> Dec
data FunDep
FunDep :: [Name] -> [Name] -> FunDep
data FamFlavour
TypeFam :: FamFlavour
DataFam :: FamFlavour
data Foreign
ImportF :: Callconv -> Safety -> String -> Name -> Type -> Foreign
ExportF :: Callconv -> String -> Name -> Type -> Foreign
data Callconv
CCall :: Callconv
StdCall :: Callconv
data Safety
Unsafe :: Safety
Safe :: Safety
Interruptible :: Safety
data Pragma
InlineP :: Name -> Inline -> RuleMatch -> Phases -> Pragma
SpecialiseP :: Name -> Type -> (Maybe Inline) -> Phases -> Pragma
SpecialiseInstP :: Type -> Pragma
RuleP :: String -> [RuleBndr] -> Exp -> Exp -> Phases -> Pragma
data Inline
NoInline :: Inline
Inline :: Inline
Inlinable :: Inline
data RuleMatch
ConLike :: RuleMatch
FunLike :: RuleMatch
data Phases
AllPhases :: Phases
FromPhase :: Int -> Phases
BeforePhase :: Int -> Phases
data RuleBndr
RuleVar :: Name -> RuleBndr
TypedRuleVar :: Name -> Type -> RuleBndr
type Cxt = [Pred]
data Pred

-- | <pre>
--   Eq (Int, a)
--   </pre>
ClassP :: Name -> [Type] -> Pred

-- | <pre>
--   F a ~ Bool
--   </pre>
EqualP :: Type -> Type -> Pred
data Strict
IsStrict :: Strict
NotStrict :: Strict
Unpacked :: Strict
data Con

-- | <pre>
--   C Int a
--   </pre>
NormalC :: Name -> [StrictType] -> Con

-- | <pre>
--   C { v :: Int, w :: a }
--   </pre>
RecC :: Name -> [VarStrictType] -> Con

-- | <pre>
--   Int :+ a
--   </pre>
InfixC :: StrictType -> Name -> StrictType -> Con

-- | <pre>
--   forall a. Eq a =&gt; C [a]
--   </pre>
ForallC :: [TyVarBndr] -> Cxt -> Con -> Con
type StrictType = (Strict, Type)
type VarStrictType = (Name, Strict, Type)
data Type

-- | <pre>
--   forall &lt;vars&gt;. &lt;ctxt&gt; -&gt; &lt;type&gt;
--   </pre>
ForallT :: [TyVarBndr] -> Cxt -> Type -> Type

-- | <pre>
--   T a b
--   </pre>
AppT :: Type -> Type -> Type

-- | <pre>
--   t :: k
--   </pre>
SigT :: Type -> Kind -> Type

-- | <pre>
--   a
--   </pre>
VarT :: Name -> Type

-- | <pre>
--   T
--   </pre>
ConT :: Name -> Type

-- | <pre>
--   'T
--   </pre>
PromotedT :: Name -> Type

-- | <pre>
--   (,), (,,), etc.
--   </pre>
TupleT :: Int -> Type

-- | <pre>
--   (), (), etc.
--   </pre>
UnboxedTupleT :: Int -> Type

-- | <pre>
--   -&gt;
--   </pre>
ArrowT :: Type

-- | <pre>
--   []
--   </pre>
ListT :: Type

-- | <pre>
--   '(), '(,), '(,,), etc.
--   </pre>
PromotedTupleT :: Int -> Type

-- | <pre>
--   '[]
--   </pre>
PromotedNilT :: Type

-- | <pre>
--   (':)
--   </pre>
PromotedConsT :: Type

-- | <pre>
--   *
--   </pre>
StarT :: Type

-- | <pre>
--   Constraint
--   </pre>
ConstraintT :: Type

-- | <pre>
--   0,1,2, etc.
--   </pre>
LitT :: TyLit -> Type
data TyVarBndr

-- | <pre>
--   a
--   </pre>
PlainTV :: Name -> TyVarBndr

-- | <pre>
--   (a :: k)
--   </pre>
KindedTV :: Name -> Kind -> TyVarBndr
data TyLit

-- | <pre>
--   2
--   </pre>
NumTyLit :: Integer -> TyLit

-- | <pre>
--   <a>Hello</a>
--   </pre>
StrTyLit :: String -> TyLit

-- | To avoid duplication between kinds and types, they are defined to be
--   the same. Naturally, you would never have a type be <a>StarT</a> and
--   you would never have a kind be <a>SigT</a>, but many of the other
--   constructors are shared. Note that the kind <tt>Bool</tt> is denoted
--   with <a>ConT</a>, not <a>PromotedT</a>. Similarly, tuple kinds are
--   made with <a>TupleT</a>, not <a>PromotedTupleT</a>.
type Kind = Type
cmpEq :: Ordering -> Bool
thenCmp :: Ordering -> Ordering -> Ordering
instance Typeable ModName
instance Typeable PkgName
instance Typeable OccName
instance Typeable NameSpace
instance Typeable NameFlavour
instance Typeable FixityDirection
instance Typeable Fixity
instance Typeable Lit
instance Typeable FamFlavour
instance Typeable Callconv
instance Typeable Safety
instance Typeable Inline
instance Typeable RuleMatch
instance Typeable Phases
instance Typeable Strict
instance Typeable TyLit
instance Typeable Name
instance Typeable FunDep
instance Typeable Type
instance Typeable TyVarBndr
instance Typeable Pred
instance Typeable Con
instance Typeable RuleBndr
instance Typeable Foreign
instance Typeable Exp
instance Typeable Match
instance Typeable Pat
instance Typeable Dec
instance Typeable Clause
instance Typeable Body
instance Typeable Guard
instance Typeable Stmt
instance Typeable Pragma
instance Typeable Range
instance Typeable Info
instance Eq ModName
instance Ord ModName
instance Data ModName
instance Eq PkgName
instance Ord PkgName
instance Data PkgName
instance Eq OccName
instance Ord OccName
instance Data OccName
instance Eq NameSpace
instance Ord NameSpace
instance Data NameSpace
instance Eq FixityDirection
instance Show FixityDirection
instance Data FixityDirection
instance Eq Fixity
instance Show Fixity
instance Data Fixity
instance Show Lit
instance Eq Lit
instance Data Lit
instance Show FamFlavour
instance Eq FamFlavour
instance Data FamFlavour
instance Show Callconv
instance Eq Callconv
instance Data Callconv
instance Show Safety
instance Eq Safety
instance Data Safety
instance Show Inline
instance Eq Inline
instance Data Inline
instance Show RuleMatch
instance Eq RuleMatch
instance Data RuleMatch
instance Show Phases
instance Eq Phases
instance Data Phases
instance Show Strict
instance Eq Strict
instance Data Strict
instance Show TyLit
instance Eq TyLit
instance Data TyLit
instance Data Name
instance Show FunDep
instance Eq FunDep
instance Data FunDep
instance Show Type
instance Eq Type
instance Data Type
instance Show TyVarBndr
instance Eq TyVarBndr
instance Data TyVarBndr
instance Show Pred
instance Eq Pred
instance Data Pred
instance Show Con
instance Eq Con
instance Data Con
instance Show RuleBndr
instance Eq RuleBndr
instance Data RuleBndr
instance Show Foreign
instance Eq Foreign
instance Data Foreign
instance Show Exp
instance Eq Exp
instance Data Exp
instance Show Match
instance Eq Match
instance Data Match
instance Show Pat
instance Eq Pat
instance Data Pat
instance Show Dec
instance Eq Dec
instance Data Dec
instance Show Clause
instance Eq Clause
instance Data Clause
instance Show Body
instance Eq Body
instance Data Body
instance Show Guard
instance Eq Guard
instance Data Guard
instance Show Stmt
instance Eq Stmt
instance Data Stmt
instance Show Pragma
instance Eq Pragma
instance Data Pragma
instance Show Range
instance Eq Range
instance Data Range
instance Show Info
instance Data Info
instance Show Name
instance Ord NameFlavour
instance Eq NameFlavour
instance Ord Name
instance Eq Name
instance Data NameFlavour
instance (Lift a, Lift b, Lift c, Lift d, Lift e, Lift f, Lift g) => Lift (a, b, c, d, e, f, g)
instance (Lift a, Lift b, Lift c, Lift d, Lift e, Lift f) => Lift (a, b, c, d, e, f)
instance (Lift a, Lift b, Lift c, Lift d, Lift e) => Lift (a, b, c, d, e)
instance (Lift a, Lift b, Lift c, Lift d) => Lift (a, b, c, d)
instance (Lift a, Lift b, Lift c) => Lift (a, b, c)
instance (Lift a, Lift b) => Lift (a, b)
instance Lift a => Lift [a]
instance (Lift a, Lift b) => Lift (Either a b)
instance Lift a => Lift (Maybe a)
instance Lift Bool
instance Lift Char
instance Lift Int
instance Lift Integer
instance Quasi Q
instance Applicative Q
instance Functor Q
instance Monad Q
instance Quasi IO


-- | TH.Lib contains lots of useful helper functions for generating and
--   manipulating Template Haskell terms
module Language.Haskell.TH.Lib
type InfoQ = Q Info
type PatQ = Q Pat
type FieldPatQ = Q FieldPat
type ExpQ = Q Exp
type DecQ = Q Dec
type DecsQ = Q [Dec]
type ConQ = Q Con
type TypeQ = Q Type
type TyLitQ = Q TyLit
type CxtQ = Q Cxt
type PredQ = Q Pred
type MatchQ = Q Match
type ClauseQ = Q Clause
type BodyQ = Q Body
type GuardQ = Q Guard
type StmtQ = Q Stmt
type RangeQ = Q Range
type StrictTypeQ = Q StrictType
type VarStrictTypeQ = Q VarStrictType
type FieldExpQ = Q FieldExp
type RuleBndrQ = Q RuleBndr
intPrimL :: Integer -> Lit
wordPrimL :: Integer -> Lit
floatPrimL :: Rational -> Lit
doublePrimL :: Rational -> Lit
integerL :: Integer -> Lit
charL :: Char -> Lit
stringL :: String -> Lit
stringPrimL :: [Word8] -> Lit
rationalL :: Rational -> Lit
litP :: Lit -> PatQ
varP :: Name -> PatQ
tupP :: [PatQ] -> PatQ
unboxedTupP :: [PatQ] -> PatQ
conP :: Name -> [PatQ] -> PatQ
infixP :: PatQ -> Name -> PatQ -> PatQ
uInfixP :: PatQ -> Name -> PatQ -> PatQ
parensP :: PatQ -> PatQ
tildeP :: PatQ -> PatQ
bangP :: PatQ -> PatQ
asP :: Name -> PatQ -> PatQ
wildP :: PatQ
recP :: Name -> [FieldPatQ] -> PatQ
listP :: [PatQ] -> PatQ
sigP :: PatQ -> TypeQ -> PatQ
viewP :: ExpQ -> PatQ -> PatQ
fieldPat :: Name -> PatQ -> FieldPatQ
bindS :: PatQ -> ExpQ -> StmtQ
letS :: [DecQ] -> StmtQ
noBindS :: ExpQ -> StmtQ
parS :: [[StmtQ]] -> StmtQ
fromR :: ExpQ -> RangeQ
fromThenR :: ExpQ -> ExpQ -> RangeQ
fromToR :: ExpQ -> ExpQ -> RangeQ
fromThenToR :: ExpQ -> ExpQ -> ExpQ -> RangeQ
normalB :: ExpQ -> BodyQ
guardedB :: [Q (Guard, Exp)] -> BodyQ
normalG :: ExpQ -> GuardQ
normalGE :: ExpQ -> ExpQ -> Q (Guard, Exp)
patG :: [StmtQ] -> GuardQ
patGE :: [StmtQ] -> ExpQ -> Q (Guard, Exp)

-- | Use with <a>caseE</a>
match :: PatQ -> BodyQ -> [DecQ] -> MatchQ

-- | Use with <a>funD</a>
clause :: [PatQ] -> BodyQ -> [DecQ] -> ClauseQ

-- | Dynamically binding a variable (unhygenic)
dyn :: String -> Q Exp
global :: Name -> ExpQ
varE :: Name -> ExpQ
conE :: Name -> ExpQ
litE :: Lit -> ExpQ
appE :: ExpQ -> ExpQ -> ExpQ
parensE :: ExpQ -> ExpQ
uInfixE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
infixE :: Maybe ExpQ -> ExpQ -> Maybe ExpQ -> ExpQ
infixApp :: ExpQ -> ExpQ -> ExpQ -> ExpQ
sectionL :: ExpQ -> ExpQ -> ExpQ
sectionR :: ExpQ -> ExpQ -> ExpQ
lamE :: [PatQ] -> ExpQ -> ExpQ

-- | Single-arg lambda
lam1E :: PatQ -> ExpQ -> ExpQ
lamCaseE :: [MatchQ] -> ExpQ
tupE :: [ExpQ] -> ExpQ
unboxedTupE :: [ExpQ] -> ExpQ
condE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
multiIfE :: [Q (Guard, Exp)] -> ExpQ
letE :: [DecQ] -> ExpQ -> ExpQ
caseE :: ExpQ -> [MatchQ] -> ExpQ
doE :: [StmtQ] -> ExpQ
compE :: [StmtQ] -> ExpQ
arithSeqE :: RangeQ -> ExpQ
listE :: [ExpQ] -> ExpQ
sigE :: ExpQ -> TypeQ -> ExpQ
recConE :: Name -> [Q (Name, Exp)] -> ExpQ
recUpdE :: ExpQ -> [Q (Name, Exp)] -> ExpQ
stringE :: String -> ExpQ
fieldExp :: Name -> ExpQ -> Q (Name, Exp)
fromE :: ExpQ -> ExpQ
fromThenE :: ExpQ -> ExpQ -> ExpQ
fromToE :: ExpQ -> ExpQ -> ExpQ
fromThenToE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
valD :: PatQ -> BodyQ -> [DecQ] -> DecQ
funD :: Name -> [ClauseQ] -> DecQ
tySynD :: Name -> [TyVarBndr] -> TypeQ -> DecQ
dataD :: CxtQ -> Name -> [TyVarBndr] -> [ConQ] -> [Name] -> DecQ
newtypeD :: CxtQ -> Name -> [TyVarBndr] -> ConQ -> [Name] -> DecQ
classD :: CxtQ -> Name -> [TyVarBndr] -> [FunDep] -> [DecQ] -> DecQ
instanceD :: CxtQ -> TypeQ -> [DecQ] -> DecQ
sigD :: Name -> TypeQ -> DecQ
forImpD :: Callconv -> Safety -> String -> Name -> TypeQ -> DecQ
infixLD :: Int -> Name -> DecQ
infixRD :: Int -> Name -> DecQ
infixND :: Int -> Name -> DecQ
pragInlD :: Name -> Inline -> RuleMatch -> Phases -> DecQ
pragSpecD :: Name -> TypeQ -> Phases -> DecQ
pragSpecInlD :: Name -> TypeQ -> Inline -> Phases -> DecQ
pragSpecInstD :: TypeQ -> DecQ
pragRuleD :: String -> [RuleBndrQ] -> ExpQ -> ExpQ -> Phases -> DecQ
familyNoKindD :: FamFlavour -> Name -> [TyVarBndr] -> DecQ
familyKindD :: FamFlavour -> Name -> [TyVarBndr] -> Kind -> DecQ
dataInstD :: CxtQ -> Name -> [TypeQ] -> [ConQ] -> [Name] -> DecQ
newtypeInstD :: CxtQ -> Name -> [TypeQ] -> ConQ -> [Name] -> DecQ
tySynInstD :: Name -> [TypeQ] -> TypeQ -> DecQ
cxt :: [PredQ] -> CxtQ
classP :: Name -> [TypeQ] -> PredQ
equalP :: TypeQ -> TypeQ -> PredQ
normalC :: Name -> [StrictTypeQ] -> ConQ
recC :: Name -> [VarStrictTypeQ] -> ConQ
infixC :: Q (Strict, Type) -> Name -> Q (Strict, Type) -> ConQ
forallC :: [TyVarBndr] -> CxtQ -> ConQ -> ConQ
forallT :: [TyVarBndr] -> CxtQ -> TypeQ -> TypeQ
varT :: Name -> TypeQ
conT :: Name -> TypeQ
appT :: TypeQ -> TypeQ -> TypeQ
arrowT :: TypeQ
listT :: TypeQ
litT :: TyLitQ -> TypeQ
tupleT :: Int -> TypeQ
unboxedTupleT :: Int -> TypeQ
sigT :: TypeQ -> Kind -> TypeQ
promotedT :: Name -> TypeQ
promotedTupleT :: Int -> TypeQ
promotedNilT :: TypeQ
promotedConsT :: TypeQ
isStrict :: Q Strict
unpacked :: Q Strict
notStrict :: Q Strict
strictType :: Q Strict -> TypeQ -> StrictTypeQ
varStrictType :: Name -> StrictTypeQ -> VarStrictTypeQ
numTyLit :: Integer -> TyLitQ
strTyLit :: String -> TyLitQ
plainTV :: Name -> TyVarBndr
kindedTV :: Name -> Kind -> TyVarBndr
varK :: Name -> Kind
conK :: Name -> Kind
tupleK :: Int -> Kind
arrowK :: Kind
listK :: Kind
appK :: Kind -> Kind -> Kind
starK :: Kind
constraintK :: Kind
cCall :: Callconv
stdCall :: Callconv
unsafe :: Safety
interruptible :: Safety
safe :: Safety
funDep :: [Name] -> [Name] -> FunDep
typeFam :: FamFlavour
dataFam :: FamFlavour
ruleVar :: Name -> RuleBndrQ
typedRuleVar :: Name -> TypeQ -> RuleBndrQ
appsE :: [ExpQ] -> ExpQ

module Language.Haskell.TH.Quote
data QuasiQuoter
QuasiQuoter :: (String -> Q Exp) -> (String -> Q Pat) -> (String -> Q Type) -> (String -> Q [Dec]) -> QuasiQuoter
quoteExp :: QuasiQuoter -> String -> Q Exp
quotePat :: QuasiQuoter -> String -> Q Pat
quoteType :: QuasiQuoter -> String -> Q Type
quoteDec :: QuasiQuoter -> String -> Q [Dec]
dataToQa :: Data a => (Name -> k) -> (Lit -> Q q) -> (k -> [Q q] -> Q q) -> (forall b. Data b => b -> Maybe (Q q)) -> a -> Q q

-- | <a>dataToExpQ</a> converts a value to a 'Q Exp' representation of the
--   same value. It takes a function to handle type-specific cases.
dataToExpQ :: Data a => (forall b. Data b => b -> Maybe (Q Exp)) -> a -> Q Exp

-- | <a>dataToPatQ</a> converts a value to a 'Q Pat' representation of the
--   same value. It takes a function to handle type-specific cases.
dataToPatQ :: Data a => (forall b. Data b => b -> Maybe (Q Pat)) -> a -> Q Pat

-- | <a>quoteFile</a> takes a <a>QuasiQuoter</a> and lifts it into one that
--   read the data out of a file. For example, suppose <tt>asmq</tt> is an
--   assembly-language quoter, so that you can write [asmq| ld r1, r2 |] as
--   an expression. Then if you define <tt>asmq_f = quoteFile asmq</tt>,
--   then the quote [asmq_f| foo.s |] will take input from file
--   <a>foo.s</a> instead of the inline text
quoteFile :: QuasiQuoter -> QuasiQuoter


-- | Monadic front-end to Text.PrettyPrint
module Language.Haskell.TH.PprLib
type Doc = PprM Doc
data PprM a

-- | An empty document
empty :: Doc

-- | A ';' character
semi :: Doc

-- | A ',' character
comma :: Doc

-- | A <tt>:</tt> character
colon :: Doc

-- | A space character
space :: Doc

-- | A '=' character
equals :: Doc

-- | A <a>-&gt;</a> string
arrow :: Doc

-- | A '(' character
lparen :: Doc

-- | A ')' character
rparen :: Doc

-- | A '[' character
lbrack :: Doc

-- | A ']' character
rbrack :: Doc

-- | A '{' character
lbrace :: Doc

-- | A '}' character
rbrace :: Doc
text :: String -> Doc
char :: Char -> Doc
ptext :: String -> Doc
int :: Int -> Doc
integer :: Integer -> Doc
float :: Float -> Doc
double :: Double -> Doc
rational :: Rational -> Doc

-- | Wrap document in <tt>(...)</tt>
parens :: Doc -> Doc

-- | Wrap document in <tt>[...]</tt>
brackets :: Doc -> Doc

-- | Wrap document in <tt>{...}</tt>
braces :: Doc -> Doc

-- | Wrap document in <tt>'...'</tt>
quotes :: Doc -> Doc

-- | Wrap document in <tt>"..."</tt>
doubleQuotes :: Doc -> Doc

-- | Beside
(<>) :: Doc -> Doc -> Doc

-- | Beside, separated by space
(<+>) :: Doc -> Doc -> Doc

-- | List version of <a>&lt;&gt;</a>
hcat :: [Doc] -> Doc

-- | List version of <a>&lt;+&gt;</a>
hsep :: [Doc] -> Doc

-- | Above; if there is no overlap it "dovetails" the two
($$) :: Doc -> Doc -> Doc

-- | Above, without dovetailing.
($+$) :: Doc -> Doc -> Doc

-- | List version of <a>$$</a>
vcat :: [Doc] -> Doc

-- | Either hsep or vcat
sep :: [Doc] -> Doc

-- | Either hcat or vcat
cat :: [Doc] -> Doc

-- | "Paragraph fill" version of sep
fsep :: [Doc] -> Doc

-- | "Paragraph fill" version of cat
fcat :: [Doc] -> Doc

-- | Nested
nest :: Int -> Doc -> Doc

-- | <pre>
--   hang d1 n d2 = sep [d1, nest n d2]
--   </pre>
hang :: Doc -> Int -> Doc -> Doc

-- | <pre>
--   punctuate p [d1, ... dn] = [d1 &lt;&gt; p, d2 &lt;&gt; p, ... dn-1 &lt;&gt; p, dn]
--   </pre>
punctuate :: Doc -> [Doc] -> [Doc]

-- | Returns <a>True</a> if the document is empty
isEmpty :: Doc -> PprM Bool
to_HPJ_Doc :: Doc -> Doc
pprName :: Name -> Doc
pprName' :: NameIs -> Name -> Doc
instance Monad PprM
instance Show Doc


-- | contains a prettyprinter for the Template Haskell datatypes
module Language.Haskell.TH.Ppr
nestDepth :: Int
type Precedence = Int
appPrec :: Precedence
noPrec :: Precedence
opPrec :: Precedence
unopPrec :: Precedence
parensIf :: Bool -> Doc -> Doc
pprint :: Ppr a => a -> String
class Ppr a where ppr_list = vcat . map ppr
ppr :: Ppr a => a -> Doc
ppr_list :: Ppr a => [a] -> Doc
ppr_sig :: Name -> Type -> Doc
pprFixity :: Name -> Fixity -> Doc
pprInfixExp :: Exp -> Doc
pprExp :: Precedence -> Exp -> Doc
pprFields :: [(Name, Exp)] -> Doc
pprMaybeExp :: Precedence -> Maybe Exp -> Doc
pprGuarded :: Doc -> (Guard, Exp) -> Doc
pprBody :: Bool -> Body -> Doc
pprLit :: Precedence -> Lit -> Doc
bytesToString :: [Word8] -> String
pprString :: String -> Doc
pprPat :: Precedence -> Pat -> Doc
ppr_dec :: Bool -> Dec -> Doc
ppr_data :: Doc -> Cxt -> Name -> Doc -> [Con] -> [Name] -> Doc
ppr_newtype :: Doc -> Cxt -> Name -> Doc -> Con -> [Name] -> Doc
ppr_tySyn :: Doc -> Name -> Doc -> Type -> Doc
pprVarStrictType :: (Name, Strict, Type) -> Doc
pprStrictType :: (Strict, Type) -> Doc
pprParendType :: Type -> Doc
pprTyApp :: (Type, [Type]) -> Doc
pprFunArgType :: Type -> Doc
split :: Type -> (Type, [Type])
pprTyLit :: TyLit -> Doc
pprCxt :: Cxt -> Doc
where_clause :: [Dec] -> Doc
showtextl :: Show a => a -> Doc
hashParens :: Doc -> Doc
quoteParens :: Doc -> Doc
instance Ppr Range
instance Ppr Pred
instance Ppr TyVarBndr
instance Ppr TyLit
instance Ppr Type
instance Ppr Con
instance Ppr Clause
instance Ppr RuleBndr
instance Ppr Phases
instance Ppr RuleMatch
instance Ppr Inline
instance Ppr Pragma
instance Ppr Foreign
instance Ppr FamFlavour
instance Ppr FunDep
instance Ppr Dec
instance Ppr Pat
instance Ppr Match
instance Ppr Stmt
instance Ppr Exp
instance Ppr Info
instance Ppr Name
instance Ppr a => Ppr [a]


-- | The public face of Template Haskell
--   
--   For other documentation, refer to:
--   <a>http://www.haskell.org/haskellwiki/Template_Haskell</a>
module Language.Haskell.TH
data Q a
runQ :: Quasi m => Q a -> m a

-- | Report an error to the user, but allow the current splice's
--   computation to carry on. To abort the computation, use <a>fail</a>.
reportError :: String -> Q ()

-- | Report a warning to the user, and carry on.
reportWarning :: String -> Q ()

-- | Report an error (True) or warning (False), but carry on; use
--   <a>fail</a> to stop.

-- | <i>Deprecated: Use reportError or reportWarning instead </i>
report :: Bool -> String -> Q ()

-- | Recover from errors raised by <a>reportError</a> or <a>fail</a>.
recover :: Q a -> Q a -> Q a

-- | The location at which this computation is spliced.
location :: Q Loc
data Loc
Loc :: String -> String -> String -> CharPos -> CharPos -> Loc
loc_filename :: Loc -> String
loc_package :: Loc -> String
loc_module :: Loc -> String
loc_start :: Loc -> CharPos
loc_end :: Loc -> CharPos

-- | The <a>runIO</a> function lets you run an I/O computation in the
--   <a>Q</a> monad. Take care: you are guaranteed the ordering of calls to
--   <a>runIO</a> within a single <a>Q</a> computation, but not about the
--   order in which splices are run.
--   
--   Note: for various murky reasons, stdout and stderr handles are not
--   necesarily flushed when the compiler finishes running, so you should
--   flush them yourself.
runIO :: IO a -> Q a

-- | <a>reify</a> looks up information about the <a>Name</a>.
--   
--   It is sometimes useful to construct the argument name using
--   <a>lookupTypeName</a> or <a>lookupValueName</a> to ensure that we are
--   reifying from the right namespace. For instance, in this context:
--   
--   <pre>
--   data D = D
--   </pre>
--   
--   which <tt>D</tt> does <tt>reify (mkName "D")</tt> return information
--   about? (Answer: <tt>D</tt>-the-type, but don't rely on it.) To ensure
--   we get information about <tt>D</tt>-the-value, use
--   <a>lookupValueName</a>:
--   
--   <pre>
--   do
--     Just nm &lt;- lookupValueName "D"
--     reify nm
--   </pre>
--   
--   and to get information about <tt>D</tt>-the-type, use
--   <a>lookupTypeName</a>.
reify :: Name -> Q Info

-- | Obtained from <a>reify</a> in the <a>Q</a> Monad.
data Info

-- | A class, with a list of its visible instances
ClassI :: Dec -> [InstanceDec] -> Info

-- | A class method
ClassOpI :: Name -> Type -> ParentName -> Fixity -> Info

-- | A "plain" type constructor. "Fancier" type constructors are returned
--   using <a>PrimTyConI</a> or <a>FamilyI</a> as appropriate
TyConI :: Dec -> Info

-- | A type or data family, with a list of its visible instances
FamilyI :: Dec -> [InstanceDec] -> Info

-- | A "primitive" type constructor, which can't be expressed with a
--   <a>Dec</a>. Examples: <tt>(-&gt;)</tt>, <tt>Int#</tt>.
PrimTyConI :: Name -> Arity -> Unlifted -> Info

-- | A data constructor
DataConI :: Name -> Type -> ParentName -> Fixity -> Info

-- | A "value" variable (as opposed to a type variable, see <a>TyVarI</a>).
--   
--   The <tt>Maybe Dec</tt> field contains <tt>Just</tt> the declaration
--   which defined the variable -- including the RHS of the declaration --
--   or else <tt>Nothing</tt>, in the case where the RHS is unavailable to
--   the compiler. At present, this value is _always_ <tt>Nothing</tt>:
--   returning the RHS has not yet been implemented because of lack of
--   interest.
VarI :: Name -> Type -> (Maybe Dec) -> Fixity -> Info

-- | A type variable.
--   
--   The <tt>Type</tt> field contains the type which underlies the
--   variable. At present, this is always <tt><a>VarT</a> theName</tt>, but
--   future changes may permit refinement of this.
TyVarI :: Name -> Type -> Info

-- | <a>InstanceDec</a> desribes a single instance of a class or type
--   function. It is just a <a>Dec</a>, but guaranteed to be one of the
--   following:
--   
--   <ul>
--   <li><a>InstanceD</a> (with empty <tt>[<a>Dec</a>]</tt>)</li>
--   <li><a>DataInstD</a> or <a>NewtypeInstD</a> (with empty derived
--   <tt>[<a>Name</a>]</tt>)</li>
--   <li><a>TySynInstD</a></li>
--   </ul>
type InstanceDec = Dec

-- | In <a>ClassOpI</a> and <a>DataConI</a>, name of the parent class or
--   type
type ParentName = Name

-- | In <a>PrimTyConI</a>, arity of the type constructor
type Arity = Int

-- | In <a>PrimTyConI</a>, is the type constructor unlifted?
type Unlifted = Bool

-- | Look up the given name in the (type namespace of the) current splice's
--   scope. See <a>Language.Haskell.TH.Syntax#namelookup</a> for more
--   details.
lookupTypeName :: String -> Q (Maybe Name)

-- | Look up the given name in the (value namespace of the) current
--   splice's scope. See <a>Language.Haskell.TH.Syntax#namelookup</a> for
--   more details.
lookupValueName :: String -> Q (Maybe Name)

-- | <tt>reifyInstances nm tys</tt> returns a list of visible instances of
--   <tt>nm tys</tt>. That is, if <tt>nm</tt> is the name of a type class,
--   then all instances of this class at the types <tt>tys</tt> are
--   returned. Alternatively, if <tt>nm</tt> is the name of a data family
--   or type family, all instances of this family at the types <tt>tys</tt>
--   are returned.
reifyInstances :: Name -> [Type] -> Q [InstanceDec]

-- | Is the list of instances returned by <a>reifyInstances</a> nonempty?
isInstance :: Name -> [Type] -> Q Bool

-- | An abstract type representing names in the syntax tree.
--   
--   <a>Name</a>s can be constructed in several ways, which come with
--   different name-capture guarantees (see
--   <a>Language.Haskell.TH.Syntax#namecapture</a> for an explanation of
--   name capture):
--   
--   <ul>
--   <li>the built-in syntax <tt>'f</tt> and <tt>''T</tt> can be used to
--   construct names, The expression <tt>'f</tt> gives a <tt>Name</tt>
--   which refers to the value <tt>f</tt> currently in scope, and
--   <tt>''T</tt> gives a <tt>Name</tt> which refers to the type <tt>T</tt>
--   currently in scope. These names can never be captured.</li>
--   <li><a>lookupValueName</a> and <a>lookupTypeName</a> are similar to
--   <tt>'f</tt> and <tt>''T</tt> respectively, but the <tt>Name</tt>s are
--   looked up at the point where the current splice is being run. These
--   names can never be captured.</li>
--   <li><a>newName</a> monadically generates a new name, which can never
--   be captured.</li>
--   <li><a>mkName</a> generates a capturable name.</li>
--   </ul>
--   
--   Names constructed using <tt>newName</tt> and <tt>mkName</tt> may be
--   used in bindings (such as <tt>let x = ...</tt> or <tt>x -&gt;
--   ...</tt>), but names constructed using <tt>lookupValueName</tt>,
--   <tt>lookupTypeName</tt>, <tt>'f</tt>, <tt>''T</tt> may not.
data Name
data NameSpace

-- | Generate a capturable name. Occurrences of such names will be resolved
--   according to the Haskell scoping rules at the occurrence site.
--   
--   For example:
--   
--   <pre>
--   f = [| pi + $(varE (mkName "pi")) |]
--   ...
--   g = let pi = 3 in $f
--   </pre>
--   
--   In this case, <tt>g</tt> is desugared to
--   
--   <pre>
--   g = Prelude.pi + 3
--   </pre>
--   
--   Note that <tt>mkName</tt> may be used with qualified names:
--   
--   <pre>
--   mkName "Prelude.pi"
--   </pre>
--   
--   See also <a>dyn</a> for a useful combinator. The above example could
--   be rewritten using <tt>dyn</tt> as
--   
--   <pre>
--   f = [| pi + $(dyn "pi") |]
--   </pre>
mkName :: String -> Name

-- | Generate a fresh name, which cannot be captured.
--   
--   For example, this:
--   
--   <pre>
--   f = $(do
--     nm1 &lt;- newName "x"
--     let nm2 = <a>mkName</a> "x"
--     return (<a>LamE</a> [<a>VarP</a> nm1] (LamE [VarP nm2] (<a>VarE</a> nm1)))
--    )
--   </pre>
--   
--   will produce the splice
--   
--   <pre>
--   f = \x0 -&gt; \x -&gt; x0
--   </pre>
--   
--   In particular, the occurrence <tt>VarE nm1</tt> refers to the binding
--   <tt>VarP nm1</tt>, and is not captured by the binding <tt>VarP
--   nm2</tt>.
--   
--   Although names generated by <tt>newName</tt> cannot <i>be
--   captured</i>, they can <i>capture</i> other names. For example, this:
--   
--   <pre>
--   g = $(do
--     nm1 &lt;- newName "x"
--     let nm2 = mkName "x"
--     return (LamE [VarP nm2] (LamE [VarP nm1] (VarE nm2)))
--    )
--   </pre>
--   
--   will produce the splice
--   
--   <pre>
--   g = \x -&gt; \x0 -&gt; x0
--   </pre>
--   
--   since the occurrence <tt>VarE nm2</tt> is captured by the innermost
--   binding of <tt>x</tt>, namely <tt>VarP nm1</tt>.
newName :: String -> Q Name

-- | The name without its module prefix
nameBase :: Name -> String

-- | Module prefix of a name, if it exists
nameModule :: Name -> Maybe String

-- | Tuple type constructor
tupleTypeName :: Int -> Name

-- | Tuple data constructor
tupleDataName :: Int -> Name

-- | Unboxed tuple type constructor
unboxedTupleTypeName :: Int -> Name

-- | Unboxed tuple data constructor
unboxedTupleDataName :: Int -> Name
data Dec

-- | <pre>
--   { f p1 p2 = b where decs }
--   </pre>
FunD :: Name -> [Clause] -> Dec

-- | <pre>
--   { p = b where decs }
--   </pre>
ValD :: Pat -> Body -> [Dec] -> Dec

-- | <pre>
--   { data Cxt x =&gt; T x = A x | B (T x)
--          deriving (Z,W)}
--   </pre>
DataD :: Cxt -> Name -> [TyVarBndr] -> [Con] -> [Name] -> Dec

-- | <pre>
--   { newtype Cxt x =&gt; T x = A (B x)
--          deriving (Z,W)}
--   </pre>
NewtypeD :: Cxt -> Name -> [TyVarBndr] -> Con -> [Name] -> Dec

-- | <pre>
--   { type T x = (x,x) }
--   </pre>
TySynD :: Name -> [TyVarBndr] -> Type -> Dec

-- | <pre>
--   { class Eq a =&gt; Ord a where ds }
--   </pre>
ClassD :: Cxt -> Name -> [TyVarBndr] -> [FunDep] -> [Dec] -> Dec

-- | <pre>
--   { instance Show w =&gt; Show [w]
--          where ds }
--   </pre>
InstanceD :: Cxt -> Type -> [Dec] -> Dec

-- | <pre>
--   { length :: [a] -&gt; Int }
--   </pre>
SigD :: Name -> Type -> Dec

-- | <pre>
--   { foreign import ... }
--   { foreign export ... }
--   </pre>
ForeignD :: Foreign -> Dec

-- | <pre>
--   { infix 3 foo }
--   </pre>
InfixD :: Fixity -> Name -> Dec

-- | <pre>
--   { {--} }
--   </pre>
PragmaD :: Pragma -> Dec

-- | <pre>
--   { type family T a b c :: * }
--   </pre>
FamilyD :: FamFlavour -> Name -> [TyVarBndr] -> (Maybe Kind) -> Dec

-- | <pre>
--   { data instance Cxt x =&gt; T [x] = A x 
--                                   | B (T x)
--          deriving (Z,W)}
--   </pre>
DataInstD :: Cxt -> Name -> [Type] -> [Con] -> [Name] -> Dec

-- | <pre>
--   { newtype instance Cxt x =&gt; T [x] = A (B x)
--          deriving (Z,W)}
--   </pre>
NewtypeInstD :: Cxt -> Name -> [Type] -> Con -> [Name] -> Dec

-- | <pre>
--   { type instance T (Maybe x) = (x,x) }
--   </pre>
TySynInstD :: Name -> [Type] -> Type -> Dec
data Con

-- | <pre>
--   C Int a
--   </pre>
NormalC :: Name -> [StrictType] -> Con

-- | <pre>
--   C { v :: Int, w :: a }
--   </pre>
RecC :: Name -> [VarStrictType] -> Con

-- | <pre>
--   Int :+ a
--   </pre>
InfixC :: StrictType -> Name -> StrictType -> Con

-- | <pre>
--   forall a. Eq a =&gt; C [a]
--   </pre>
ForallC :: [TyVarBndr] -> Cxt -> Con -> Con
data Clause

-- | <pre>
--   f { p1 p2 = body where decs }
--   </pre>
Clause :: [Pat] -> Body -> [Dec] -> Clause
data Strict
IsStrict :: Strict
NotStrict :: Strict
Unpacked :: Strict
data Foreign
ImportF :: Callconv -> Safety -> String -> Name -> Type -> Foreign
ExportF :: Callconv -> String -> Name -> Type -> Foreign
data Callconv
CCall :: Callconv
StdCall :: Callconv
data Safety
Unsafe :: Safety
Safe :: Safety
Interruptible :: Safety
data Pragma
InlineP :: Name -> Inline -> RuleMatch -> Phases -> Pragma
SpecialiseP :: Name -> Type -> (Maybe Inline) -> Phases -> Pragma
SpecialiseInstP :: Type -> Pragma
RuleP :: String -> [RuleBndr] -> Exp -> Exp -> Phases -> Pragma
data Inline
NoInline :: Inline
Inline :: Inline
Inlinable :: Inline
data RuleMatch
ConLike :: RuleMatch
FunLike :: RuleMatch
data Phases
AllPhases :: Phases
FromPhase :: Int -> Phases
BeforePhase :: Int -> Phases
data RuleBndr
RuleVar :: Name -> RuleBndr
TypedRuleVar :: Name -> Type -> RuleBndr
data FunDep
FunDep :: [Name] -> [Name] -> FunDep
data FamFlavour
TypeFam :: FamFlavour
DataFam :: FamFlavour
data Fixity
Fixity :: Int -> FixityDirection -> Fixity
data FixityDirection
InfixL :: FixityDirection
InfixR :: FixityDirection
InfixN :: FixityDirection

-- | Default fixity: <tt>infixl 9</tt>
defaultFixity :: Fixity

-- | Highest allowed operator precedence for <a>Fixity</a> constructor
--   (answer: 9)
maxPrecedence :: Int
data Exp

-- | <pre>
--   { x }
--   </pre>
VarE :: Name -> Exp

-- | <pre>
--   data T1 = C1 t1 t2; p = {C1} e1 e2
--   </pre>
ConE :: Name -> Exp

-- | <pre>
--   { 5 or <tt>c</tt>}
--   </pre>
LitE :: Lit -> Exp

-- | <pre>
--   { f x }
--   </pre>
AppE :: Exp -> Exp -> Exp

-- | <pre>
--   {x + y} or {(x+)} or {(+ x)} or {(+)}
--   </pre>
InfixE :: (Maybe Exp) -> Exp -> (Maybe Exp) -> Exp

-- | <pre>
--   {x + y}
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
UInfixE :: Exp -> Exp -> Exp -> Exp

-- | <pre>
--   { (e) }
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
ParensE :: Exp -> Exp

-- | <pre>
--   {  p1 p2 -&gt; e }
--   </pre>
LamE :: [Pat] -> Exp -> Exp

-- | <pre>
--   { case m1; m2 }
--   </pre>
LamCaseE :: [Match] -> Exp

-- | <pre>
--   { (e1,e2) }
--   </pre>
TupE :: [Exp] -> Exp

-- | <pre>
--   { () }
--   </pre>
UnboxedTupE :: [Exp] -> Exp

-- | <pre>
--   { if e1 then e2 else e3 }
--   </pre>
CondE :: Exp -> Exp -> Exp -> Exp

-- | <pre>
--   { if | g1 -&gt; e1 | g2 -&gt; e2 }
--   </pre>
MultiIfE :: [(Guard, Exp)] -> Exp

-- | <pre>
--   { let x=e1;   y=e2 in e3 }
--   </pre>
LetE :: [Dec] -> Exp -> Exp

-- | <pre>
--   { case e of m1; m2 }
--   </pre>
CaseE :: Exp -> [Match] -> Exp

-- | <pre>
--   { do { p &lt;- e1; e2 }  }
--   </pre>
DoE :: [Stmt] -> Exp

-- | <pre>
--   { [ (x,y) | x &lt;- xs, y &lt;- ys ] }
--   </pre>
--   
--   The result expression of the comprehension is the <i>last</i> of the
--   <tt><a>Stmt</a></tt>s, and should be a <a>NoBindS</a>.
--   
--   E.g. translation:
--   
--   <pre>
--   [ f x | x &lt;- xs ]
--   </pre>
--   
--   <pre>
--   CompE [BindS (VarP x) (VarE xs), NoBindS (AppE (VarE f) (VarE x))]
--   </pre>
CompE :: [Stmt] -> Exp

-- | <pre>
--   { [ 1 ,2 .. 10 ] }
--   </pre>
ArithSeqE :: Range -> Exp

-- | <pre>
--   { [1,2,3] }
--   </pre>
ListE :: [Exp] -> Exp

-- | <pre>
--   { e :: t }
--   </pre>
SigE :: Exp -> Type -> Exp

-- | <pre>
--   { T { x = y, z = w } }
--   </pre>
RecConE :: Name -> [FieldExp] -> Exp

-- | <pre>
--   { (f x) { z = w } }
--   </pre>
RecUpdE :: Exp -> [FieldExp] -> Exp
data Match

-- | <pre>
--   case e of { pat -&gt; body where decs }
--   </pre>
Match :: Pat -> Body -> [Dec] -> Match
data Body

-- | <pre>
--   f p { | e1 = e2 
--         | e3 = e4 } 
--    where ds
--   </pre>
GuardedB :: [(Guard, Exp)] -> Body

-- | <pre>
--   f p { = e } where ds
--   </pre>
NormalB :: Exp -> Body
data Guard

-- | <pre>
--   f x { | odd x } = x
--   </pre>
NormalG :: Exp -> Guard

-- | <pre>
--   f x { | Just y &lt;- x, Just z &lt;- y } = z
--   </pre>
PatG :: [Stmt] -> Guard
data Stmt
BindS :: Pat -> Exp -> Stmt
LetS :: [Dec] -> Stmt
NoBindS :: Exp -> Stmt
ParS :: [[Stmt]] -> Stmt
data Range
FromR :: Exp -> Range
FromThenR :: Exp -> Exp -> Range
FromToR :: Exp -> Exp -> Range
FromThenToR :: Exp -> Exp -> Exp -> Range
data Lit
CharL :: Char -> Lit
StringL :: String -> Lit

-- | Used for overloaded and non-overloaded literals. We don't have a good
--   way to represent non-overloaded literals at the moment. Maybe that
--   doesn't matter?
IntegerL :: Integer -> Lit
RationalL :: Rational -> Lit
IntPrimL :: Integer -> Lit
WordPrimL :: Integer -> Lit
FloatPrimL :: Rational -> Lit
DoublePrimL :: Rational -> Lit

-- | A primitive C-style string, type Addr#
StringPrimL :: [Word8] -> Lit

-- | Pattern in Haskell given in <tt>{}</tt>
data Pat

-- | <pre>
--   { 5 or <tt>c</tt> }
--   </pre>
LitP :: Lit -> Pat

-- | <pre>
--   { x }
--   </pre>
VarP :: Name -> Pat

-- | <pre>
--   { (p1,p2) }
--   </pre>
TupP :: [Pat] -> Pat

-- | <pre>
--   { () }
--   </pre>
UnboxedTupP :: [Pat] -> Pat

-- | <pre>
--   data T1 = C1 t1 t2; {C1 p1 p1} = e
--   </pre>
ConP :: Name -> [Pat] -> Pat

-- | <pre>
--   foo ({x :+ y}) = e
--   </pre>
InfixP :: Pat -> Name -> Pat -> Pat

-- | <pre>
--   foo ({x :+ y}) = e
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
UInfixP :: Pat -> Name -> Pat -> Pat

-- | <pre>
--   {(p)}
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
ParensP :: Pat -> Pat

-- | <pre>
--   { ~p }
--   </pre>
TildeP :: Pat -> Pat

-- | <pre>
--   { !p }
--   </pre>
BangP :: Pat -> Pat

-- | <pre>
--   { x @ p }
--   </pre>
AsP :: Name -> Pat -> Pat

-- | <pre>
--   { _ }
--   </pre>
WildP :: Pat

-- | <pre>
--   f (Pt { pointx = x }) = g x
--   </pre>
RecP :: Name -> [FieldPat] -> Pat

-- | <pre>
--   { [1,2,3] }
--   </pre>
ListP :: [Pat] -> Pat

-- | <pre>
--   { p :: t }
--   </pre>
SigP :: Pat -> Type -> Pat

-- | <pre>
--   { e -&gt; p }
--   </pre>
ViewP :: Exp -> Pat -> Pat
type FieldExp = (Name, Exp)
type FieldPat = (Name, Pat)
data Type

-- | <pre>
--   forall &lt;vars&gt;. &lt;ctxt&gt; -&gt; &lt;type&gt;
--   </pre>
ForallT :: [TyVarBndr] -> Cxt -> Type -> Type

-- | <pre>
--   T a b
--   </pre>
AppT :: Type -> Type -> Type

-- | <pre>
--   t :: k
--   </pre>
SigT :: Type -> Kind -> Type

-- | <pre>
--   a
--   </pre>
VarT :: Name -> Type

-- | <pre>
--   T
--   </pre>
ConT :: Name -> Type

-- | <pre>
--   'T
--   </pre>
PromotedT :: Name -> Type

-- | <pre>
--   (,), (,,), etc.
--   </pre>
TupleT :: Int -> Type

-- | <pre>
--   (), (), etc.
--   </pre>
UnboxedTupleT :: Int -> Type

-- | <pre>
--   -&gt;
--   </pre>
ArrowT :: Type

-- | <pre>
--   []
--   </pre>
ListT :: Type

-- | <pre>
--   '(), '(,), '(,,), etc.
--   </pre>
PromotedTupleT :: Int -> Type

-- | <pre>
--   '[]
--   </pre>
PromotedNilT :: Type

-- | <pre>
--   (':)
--   </pre>
PromotedConsT :: Type

-- | <pre>
--   *
--   </pre>
StarT :: Type

-- | <pre>
--   Constraint
--   </pre>
ConstraintT :: Type

-- | <pre>
--   0,1,2, etc.
--   </pre>
LitT :: TyLit -> Type
data TyVarBndr

-- | <pre>
--   a
--   </pre>
PlainTV :: Name -> TyVarBndr

-- | <pre>
--   (a :: k)
--   </pre>
KindedTV :: Name -> Kind -> TyVarBndr
data TyLit

-- | <pre>
--   2
--   </pre>
NumTyLit :: Integer -> TyLit

-- | <pre>
--   <a>Hello</a>
--   </pre>
StrTyLit :: String -> TyLit

-- | To avoid duplication between kinds and types, they are defined to be
--   the same. Naturally, you would never have a type be <a>StarT</a> and
--   you would never have a kind be <a>SigT</a>, but many of the other
--   constructors are shared. Note that the kind <tt>Bool</tt> is denoted
--   with <a>ConT</a>, not <a>PromotedT</a>. Similarly, tuple kinds are
--   made with <a>TupleT</a>, not <a>PromotedTupleT</a>.
type Kind = Type
type Cxt = [Pred]
data Pred

-- | <pre>
--   Eq (Int, a)
--   </pre>
ClassP :: Name -> [Type] -> Pred

-- | <pre>
--   F a ~ Bool
--   </pre>
EqualP :: Type -> Type -> Pred
type InfoQ = Q Info
type ExpQ = Q Exp
type DecQ = Q Dec
type DecsQ = Q [Dec]
type ConQ = Q Con
type TypeQ = Q Type
type TyLitQ = Q TyLit
type CxtQ = Q Cxt
type PredQ = Q Pred
type MatchQ = Q Match
type ClauseQ = Q Clause
type BodyQ = Q Body
type GuardQ = Q Guard
type StmtQ = Q Stmt
type RangeQ = Q Range
type StrictTypeQ = Q StrictType
type VarStrictTypeQ = Q VarStrictType
type PatQ = Q Pat
type FieldPatQ = Q FieldPat
type RuleBndrQ = Q RuleBndr
intPrimL :: Integer -> Lit
wordPrimL :: Integer -> Lit
floatPrimL :: Rational -> Lit
doublePrimL :: Rational -> Lit
integerL :: Integer -> Lit
rationalL :: Rational -> Lit
charL :: Char -> Lit
stringL :: String -> Lit
stringPrimL :: [Word8] -> Lit
litP :: Lit -> PatQ
varP :: Name -> PatQ
tupP :: [PatQ] -> PatQ
conP :: Name -> [PatQ] -> PatQ
uInfixP :: PatQ -> Name -> PatQ -> PatQ
parensP :: PatQ -> PatQ
infixP :: PatQ -> Name -> PatQ -> PatQ
tildeP :: PatQ -> PatQ
bangP :: PatQ -> PatQ
asP :: Name -> PatQ -> PatQ
wildP :: PatQ
recP :: Name -> [FieldPatQ] -> PatQ
listP :: [PatQ] -> PatQ
sigP :: PatQ -> TypeQ -> PatQ
viewP :: ExpQ -> PatQ -> PatQ
fieldPat :: Name -> PatQ -> FieldPatQ
normalB :: ExpQ -> BodyQ
guardedB :: [Q (Guard, Exp)] -> BodyQ
normalG :: ExpQ -> GuardQ
normalGE :: ExpQ -> ExpQ -> Q (Guard, Exp)
patG :: [StmtQ] -> GuardQ
patGE :: [StmtQ] -> ExpQ -> Q (Guard, Exp)

-- | Use with <a>caseE</a>
match :: PatQ -> BodyQ -> [DecQ] -> MatchQ

-- | Use with <a>funD</a>
clause :: [PatQ] -> BodyQ -> [DecQ] -> ClauseQ

-- | Dynamically binding a variable (unhygenic)
dyn :: String -> Q Exp
global :: Name -> ExpQ
varE :: Name -> ExpQ
conE :: Name -> ExpQ
litE :: Lit -> ExpQ
appE :: ExpQ -> ExpQ -> ExpQ
uInfixE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
parensE :: ExpQ -> ExpQ
infixE :: Maybe ExpQ -> ExpQ -> Maybe ExpQ -> ExpQ
infixApp :: ExpQ -> ExpQ -> ExpQ -> ExpQ
sectionL :: ExpQ -> ExpQ -> ExpQ
sectionR :: ExpQ -> ExpQ -> ExpQ
lamE :: [PatQ] -> ExpQ -> ExpQ

-- | Single-arg lambda
lam1E :: PatQ -> ExpQ -> ExpQ
lamCaseE :: [MatchQ] -> ExpQ
tupE :: [ExpQ] -> ExpQ
condE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
multiIfE :: [Q (Guard, Exp)] -> ExpQ
letE :: [DecQ] -> ExpQ -> ExpQ
caseE :: ExpQ -> [MatchQ] -> ExpQ
appsE :: [ExpQ] -> ExpQ
listE :: [ExpQ] -> ExpQ
sigE :: ExpQ -> TypeQ -> ExpQ
recConE :: Name -> [Q (Name, Exp)] -> ExpQ
recUpdE :: ExpQ -> [Q (Name, Exp)] -> ExpQ
stringE :: String -> ExpQ
fieldExp :: Name -> ExpQ -> Q (Name, Exp)
fromE :: ExpQ -> ExpQ
fromThenE :: ExpQ -> ExpQ -> ExpQ
fromToE :: ExpQ -> ExpQ -> ExpQ
fromThenToE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
arithSeqE :: RangeQ -> ExpQ
fromR :: ExpQ -> RangeQ
fromThenR :: ExpQ -> ExpQ -> RangeQ
fromToR :: ExpQ -> ExpQ -> RangeQ
fromThenToR :: ExpQ -> ExpQ -> ExpQ -> RangeQ
doE :: [StmtQ] -> ExpQ
compE :: [StmtQ] -> ExpQ
bindS :: PatQ -> ExpQ -> StmtQ
letS :: [DecQ] -> StmtQ
noBindS :: ExpQ -> StmtQ
parS :: [[StmtQ]] -> StmtQ
forallT :: [TyVarBndr] -> CxtQ -> TypeQ -> TypeQ
varT :: Name -> TypeQ
conT :: Name -> TypeQ
appT :: TypeQ -> TypeQ -> TypeQ
arrowT :: TypeQ
listT :: TypeQ
tupleT :: Int -> TypeQ
sigT :: TypeQ -> Kind -> TypeQ
litT :: TyLitQ -> TypeQ
promotedT :: Name -> TypeQ
promotedTupleT :: Int -> TypeQ
promotedNilT :: TypeQ
promotedConsT :: TypeQ
numTyLit :: Integer -> TyLitQ
strTyLit :: String -> TyLitQ
isStrict :: Q Strict
notStrict :: Q Strict
strictType :: Q Strict -> TypeQ -> StrictTypeQ
varStrictType :: Name -> StrictTypeQ -> VarStrictTypeQ
cxt :: [PredQ] -> CxtQ
classP :: Name -> [TypeQ] -> PredQ
equalP :: TypeQ -> TypeQ -> PredQ
normalC :: Name -> [StrictTypeQ] -> ConQ
recC :: Name -> [VarStrictTypeQ] -> ConQ
infixC :: Q (Strict, Type) -> Name -> Q (Strict, Type) -> ConQ
forallC :: [TyVarBndr] -> CxtQ -> ConQ -> ConQ
varK :: Name -> Kind
conK :: Name -> Kind
tupleK :: Int -> Kind
arrowK :: Kind
listK :: Kind
appK :: Kind -> Kind -> Kind
starK :: Kind
constraintK :: Kind
valD :: PatQ -> BodyQ -> [DecQ] -> DecQ
funD :: Name -> [ClauseQ] -> DecQ
tySynD :: Name -> [TyVarBndr] -> TypeQ -> DecQ
dataD :: CxtQ -> Name -> [TyVarBndr] -> [ConQ] -> [Name] -> DecQ
newtypeD :: CxtQ -> Name -> [TyVarBndr] -> ConQ -> [Name] -> DecQ
classD :: CxtQ -> Name -> [TyVarBndr] -> [FunDep] -> [DecQ] -> DecQ
instanceD :: CxtQ -> TypeQ -> [DecQ] -> DecQ
sigD :: Name -> TypeQ -> DecQ
familyNoKindD :: FamFlavour -> Name -> [TyVarBndr] -> DecQ
familyKindD :: FamFlavour -> Name -> [TyVarBndr] -> Kind -> DecQ
dataInstD :: CxtQ -> Name -> [TypeQ] -> [ConQ] -> [Name] -> DecQ
newtypeInstD :: CxtQ -> Name -> [TypeQ] -> ConQ -> [Name] -> DecQ
tySynInstD :: Name -> [TypeQ] -> TypeQ -> DecQ
typeFam :: FamFlavour
dataFam :: FamFlavour
cCall :: Callconv
stdCall :: Callconv
unsafe :: Safety
safe :: Safety
forImpD :: Callconv -> Safety -> String -> Name -> TypeQ -> DecQ
ruleVar :: Name -> RuleBndrQ
typedRuleVar :: Name -> TypeQ -> RuleBndrQ
pragInlD :: Name -> Inline -> RuleMatch -> Phases -> DecQ
pragSpecD :: Name -> TypeQ -> Phases -> DecQ
pragSpecInlD :: Name -> TypeQ -> Inline -> Phases -> DecQ
pragSpecInstD :: TypeQ -> DecQ
pragRuleD :: String -> [RuleBndrQ] -> ExpQ -> ExpQ -> Phases -> DecQ
class Ppr a where ppr_list = vcat . map ppr
ppr :: Ppr a => a -> Doc
ppr_list :: Ppr a => [a] -> Doc
pprint :: Ppr a => a -> String
pprExp :: Precedence -> Exp -> Doc
pprLit :: Precedence -> Lit -> Doc
pprPat :: Precedence -> Pat -> Doc
pprParendType :: Type -> Doc
