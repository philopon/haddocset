<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>GHC/Base.lhs</title>
<link type="text/css" rel="stylesheet" href="hscolour.css"></link>
</head>
<body>
\section[GHC.Base]{Module @GHC.Base@}

The overall structure of the GHC Prelude is a bit tricky.

  a) We want to avoid &quot;orphan modules&quot;, i.e. ones with instance
        decls that don't belong either to a tycon or a class
        defined in the same module

  b) We want to avoid giant modules

So the rough structure is as follows, in (linearised) dependency order


GHC.Prim                Has no implementation.  It defines built-in things, and
                by importing it you bring them into scope.
                The source file is GHC.Prim.hi-boot, which is just
                copied to make GHC.Prim.hi

GHC.Base        Classes: Eq, Ord, Functor, Monad
                Types:   list, (), Int, Bool, Ordering, Char, String

Data.Tuple      Types: tuples, plus instances for GHC.Base classes

GHC.Show        Class: Show, plus instances for GHC.Base/GHC.Tup types

GHC.Enum        Class: Enum,  plus instances for GHC.Base/GHC.Tup types

Data.Maybe      Type: Maybe, plus instances for GHC.Base classes

GHC.List        List functions

GHC.Num         Class: Num, plus instances for Int
                Type:  Integer, plus instances for all classes so far (Eq, Ord, Num, Show)

                Integer is needed here because it is mentioned in the signature
                of 'fromInteger' in class Num

GHC.Real        Classes: Real, Integral, Fractional, RealFrac
                         plus instances for Int, Integer
                Types:  Ratio, Rational
                        plus intances for classes so far

                Rational is needed here because it is mentioned in the signature
                of 'toRational' in class Real

GHC.ST  The ST monad, instances and a few helper functions

Ix              Classes: Ix, plus instances for Int, Bool, Char, Integer, Ordering, tuples

GHC.Arr         Types: Array, MutableArray, MutableVar

                Arrays are used by a function in GHC.Float

GHC.Float       Classes: Floating, RealFloat
                Types:   Float, Double, plus instances of all classes so far

                This module contains everything to do with floating point.
                It is a big module (900 lines)
                With a bit of luck, many modules can be compiled without ever reading GHC.Float.hi


Other Prelude modules are much easier with fewer complex dependencies.

\begin{code}
<pre><a name="line-1"></a><span class="hs-comment">{-# LANGUAGE Unsafe #-}</span>
<a name="line-2"></a><span class="hs-comment">{-# LANGUAGE CPP
<a name="line-3"></a>           , NoImplicitPrelude
<a name="line-4"></a>           , BangPatterns
<a name="line-5"></a>           , ExplicitForAll
<a name="line-6"></a>           , MagicHash
<a name="line-7"></a>           , UnboxedTuples
<a name="line-8"></a>           , ExistentialQuantification
<a name="line-9"></a>           , Rank2Types
<a name="line-10"></a>  #-}</span>
<a name="line-11"></a><span class="hs-comment">-- -fno-warn-orphans is needed for things like:</span>
<a name="line-12"></a><span class="hs-comment">-- Orphan rule: &quot;x# -# x#&quot; ALWAYS forall x# :: Int# -# x# x# = 0</span>
<a name="line-13"></a><span class="hs-comment">{-# OPTIONS_GHC -fno-warn-orphans #-}</span>
<a name="line-14"></a><span class="hs-comment">{-# OPTIONS_HADDOCK hide #-}</span>
<a name="line-15"></a>
<a name="line-16"></a><span class="hs-comment">-----------------------------------------------------------------------------</span>
<a name="line-17"></a><span class="hs-comment">-- |</span>
<a name="line-18"></a><span class="hs-comment">-- Module      :  GHC.Base</span>
<a name="line-19"></a><span class="hs-comment">-- Copyright   :  (c) The University of Glasgow, 1992-2002</span>
<a name="line-20"></a><span class="hs-comment">-- License     :  see libraries/base/LICENSE</span>
<a name="line-21"></a><span class="hs-comment">-- </span>
<a name="line-22"></a><span class="hs-comment">-- Maintainer  :  cvs-ghc@haskell.org</span>
<a name="line-23"></a><span class="hs-comment">-- Stability   :  internal</span>
<a name="line-24"></a><span class="hs-comment">-- Portability :  non-portable (GHC extensions)</span>
<a name="line-25"></a><span class="hs-comment">--</span>
<a name="line-26"></a><span class="hs-comment">-- Basic data types and classes.</span>
<a name="line-27"></a><span class="hs-comment">-- </span>
<a name="line-28"></a><span class="hs-comment">-----------------------------------------------------------------------------</span>
<a name="line-29"></a>
<a name="line-30"></a><span class="hs-cpp">#include &quot;MachDeps.h&quot;</span>
<a name="line-31"></a>
<a name="line-32"></a><span class="hs-comment">-- #hide</span>
<a name="line-33"></a><span class="hs-keyword">module</span> <span class="hs-conid">GHC</span><span class="hs-varop">.</span><span class="hs-conid">Base</span>
<a name="line-34"></a>        <span class="hs-layout">(</span>
<a name="line-35"></a>        <span class="hs-keyword">module</span> <span class="hs-conid">GHC</span><span class="hs-varop">.</span><span class="hs-conid">Base</span><span class="hs-layout">,</span>
<a name="line-36"></a>        <span class="hs-keyword">module</span> <span class="hs-conid">GHC</span><span class="hs-varop">.</span><span class="hs-conid">Classes</span><span class="hs-layout">,</span>
<a name="line-37"></a>        <span class="hs-keyword">module</span> <span class="hs-conid">GHC</span><span class="hs-varop">.</span><span class="hs-conid">CString</span><span class="hs-layout">,</span>
<a name="line-38"></a>        <span class="hs-keyword">module</span> <span class="hs-conid">GHC</span><span class="hs-varop">.</span><span class="hs-conid">Types</span><span class="hs-layout">,</span>
<a name="line-39"></a>        <span class="hs-keyword">module</span> <span class="hs-conid">GHC</span><span class="hs-varop">.</span><span class="hs-conid">Prim</span><span class="hs-layout">,</span>        <span class="hs-comment">-- Re-export GHC.Prim and GHC.Err, to avoid lots</span>
<a name="line-40"></a>        <span class="hs-keyword">module</span> <span class="hs-conid">GHC</span><span class="hs-varop">.</span><span class="hs-conid">Err</span>          <span class="hs-comment">-- of people having to import it explicitly</span>
<a name="line-41"></a>  <span class="hs-layout">)</span> 
<a name="line-42"></a>        <span class="hs-keyword">where</span>
<a name="line-43"></a>
<a name="line-44"></a><span class="hs-keyword">import</span> <span class="hs-conid">GHC</span><span class="hs-varop">.</span><span class="hs-conid">Types</span>
<a name="line-45"></a><span class="hs-keyword">import</span> <span class="hs-conid">GHC</span><span class="hs-varop">.</span><span class="hs-conid">Classes</span>
<a name="line-46"></a><span class="hs-keyword">import</span> <span class="hs-conid">GHC</span><span class="hs-varop">.</span><span class="hs-conid">CString</span>
<a name="line-47"></a><span class="hs-keyword">import</span> <span class="hs-conid">GHC</span><span class="hs-varop">.</span><span class="hs-conid">Prim</span>
<a name="line-48"></a><span class="hs-keyword">import</span> <span class="hs-comment">{-# SOURCE #-}</span> <span class="hs-conid">GHC</span><span class="hs-varop">.</span><span class="hs-conid">Err</span>
<a name="line-49"></a><span class="hs-keyword">import</span> <span class="hs-comment">{-# SOURCE #-}</span> <span class="hs-conid">GHC</span><span class="hs-varop">.</span><span class="hs-conid">IO</span> <span class="hs-layout">(</span><span class="hs-varid">failIO</span><span class="hs-layout">)</span>
<a name="line-50"></a>
<a name="line-51"></a><span class="hs-comment">-- This is not strictly speaking required by this module, but is an</span>
<a name="line-52"></a><span class="hs-comment">-- implicit dependency whenever () or tuples are mentioned, so adding it</span>
<a name="line-53"></a><span class="hs-comment">-- as an import here helps to get the dependencies right in the new</span>
<a name="line-54"></a><span class="hs-comment">-- build system.</span>
<a name="line-55"></a><span class="hs-keyword">import</span> <span class="hs-conid">GHC</span><span class="hs-varop">.</span><span class="hs-conid">Tuple</span> <span class="hs-conid">()</span>
<a name="line-56"></a><span class="hs-comment">-- Likewise we need Integer when deriving things like Eq instances, and</span>
<a name="line-57"></a><span class="hs-comment">-- this is a convenient place to force it to be built</span>
<a name="line-58"></a><span class="hs-keyword">import</span> <span class="hs-conid">GHC</span><span class="hs-varop">.</span><span class="hs-conid">Integer</span> <span class="hs-conid">()</span>
<a name="line-59"></a>
<a name="line-60"></a><span class="hs-keyword">infixr</span> <span class="hs-num">9</span>  <span class="hs-varop">.</span>
<a name="line-61"></a><span class="hs-keyword">infixr</span> <span class="hs-num">5</span>  <span class="hs-varop">++</span>
<a name="line-62"></a><span class="hs-keyword">infixl</span> <span class="hs-num">4</span>  <span class="hs-varop">&lt;$</span>
<a name="line-63"></a><span class="hs-keyword">infixl</span> <span class="hs-num">1</span>  <span class="hs-varop">&gt;&gt;</span><span class="hs-layout">,</span> <span class="hs-varop">&gt;&gt;=</span>
<a name="line-64"></a><span class="hs-keyword">infixr</span> <span class="hs-num">0</span>  <span class="hs-varop">$</span>
<a name="line-65"></a>
<a name="line-66"></a><span class="hs-keyword">default</span> <span class="hs-conid">()</span>              <span class="hs-comment">-- Double isn't available yet</span>
</pre>\end{code}


%*********************************************************
%*                                                      *
\subsection{DEBUGGING STUFF}
%*  (for use when compiling GHC.Base itself doesn't work)
%*                                                      *
%*********************************************************

\begin{code}
<pre><a name="line-1"></a><span class="hs-comment">{-
<a name="line-2"></a>data  Bool  =  False | True
<a name="line-3"></a>data Ordering = LT | EQ | GT 
<a name="line-4"></a>data Char = C# Char#
<a name="line-5"></a>type  String = [Char]
<a name="line-6"></a>data Int = I# Int#
<a name="line-7"></a>data  ()  =  ()
<a name="line-8"></a>data [] a = MkNil
<a name="line-9"></a>
<a name="line-10"></a>not True = False
<a name="line-11"></a>(&amp;&amp;) True True = True
<a name="line-12"></a>otherwise = True
<a name="line-13"></a>
<a name="line-14"></a>build = error &quot;urk&quot;
<a name="line-15"></a>foldr = error &quot;urk&quot;
<a name="line-16"></a>-}</span>
</pre>\end{code}


%*********************************************************
%*                                                      *
\subsection{Monadic classes @Functor@, @Monad@ }
%*                                                      *
%*********************************************************

\begin{code}
<pre><a name="line-1"></a><span class="hs-comment">{- | The 'Functor' class is used for types that can be mapped over.
<a name="line-2"></a>Instances of 'Functor' should satisfy the following laws:
<a name="line-3"></a>
<a name="line-4"></a>&gt; fmap id  ==  id
<a name="line-5"></a>&gt; fmap (f . g)  ==  fmap f . fmap g
<a name="line-6"></a>
<a name="line-7"></a>The instances of 'Functor' for lists, 'Data.Maybe.Maybe' and 'System.IO.IO'
<a name="line-8"></a>satisfy these laws.
<a name="line-9"></a>-}</span>
<a name="line-10"></a>
<a name="line-11"></a><a name="Functor"></a><span class="hs-keyword">class</span>  <span class="hs-conid">Functor</span> <span class="hs-varid">f</span>  <span class="hs-keyword">where</span>
<a name="line-12"></a>    <span class="hs-varid">fmap</span>        <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">b</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">f</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">f</span> <span class="hs-varid">b</span>
<a name="line-13"></a>
<a name="line-14"></a>    <span class="hs-comment">-- | Replace all locations in the input with the same value.</span>
<a name="line-15"></a>    <span class="hs-comment">-- The default definition is @'fmap' . 'const'@, but this may be</span>
<a name="line-16"></a>    <span class="hs-comment">-- overridden with a more efficient version.</span>
<a name="line-17"></a>    <span class="hs-layout">(</span><span class="hs-varop">&lt;$</span><span class="hs-layout">)</span>        <span class="hs-keyglyph">::</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">f</span> <span class="hs-varid">b</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">f</span> <span class="hs-varid">a</span>
<a name="line-18"></a>    <span class="hs-layout">(</span><span class="hs-varop">&lt;$</span><span class="hs-layout">)</span>        <span class="hs-keyglyph">=</span>  <span class="hs-varid">fmap</span> <span class="hs-varop">.</span> <span class="hs-varid">const</span>
<a name="line-19"></a>
<a name="line-20"></a><span class="hs-comment">{- | The 'Monad' class defines the basic operations over a /monad/,
<a name="line-21"></a>a concept from a branch of mathematics known as /category theory/.
<a name="line-22"></a>From the perspective of a Haskell programmer, however, it is best to
<a name="line-23"></a>think of a monad as an /abstract datatype/ of actions.
<a name="line-24"></a>Haskell's @do@ expressions provide a convenient syntax for writing
<a name="line-25"></a>monadic expressions.
<a name="line-26"></a>
<a name="line-27"></a>Minimal complete definition: '&gt;&gt;=' and 'return'.
<a name="line-28"></a>
<a name="line-29"></a>Instances of 'Monad' should satisfy the following laws:
<a name="line-30"></a>
<a name="line-31"></a>&gt; return a &gt;&gt;= k  ==  k a
<a name="line-32"></a>&gt; m &gt;&gt;= return  ==  m
<a name="line-33"></a>&gt; m &gt;&gt;= (\x -&gt; k x &gt;&gt;= h)  ==  (m &gt;&gt;= k) &gt;&gt;= h
<a name="line-34"></a>
<a name="line-35"></a>Instances of both 'Monad' and 'Functor' should additionally satisfy the law:
<a name="line-36"></a>
<a name="line-37"></a>&gt; fmap f xs  ==  xs &gt;&gt;= return . f
<a name="line-38"></a>
<a name="line-39"></a>The instances of 'Monad' for lists, 'Data.Maybe.Maybe' and 'System.IO.IO'
<a name="line-40"></a>defined in the &quot;Prelude&quot; satisfy these laws.
<a name="line-41"></a>-}</span>
<a name="line-42"></a>
<a name="line-43"></a><a name="Monad"></a><span class="hs-keyword">class</span>  <span class="hs-conid">Monad</span> <span class="hs-varid">m</span>  <span class="hs-keyword">where</span>
<a name="line-44"></a>    <span class="hs-comment">-- | Sequentially compose two actions, passing any value produced</span>
<a name="line-45"></a>    <span class="hs-comment">-- by the first as an argument to the second.</span>
<a name="line-46"></a>    <span class="hs-layout">(</span><span class="hs-varop">&gt;&gt;=</span><span class="hs-layout">)</span>       <span class="hs-keyglyph">::</span> <span class="hs-keyword">forall</span> <span class="hs-varid">a</span> <span class="hs-varid">b</span><span class="hs-varop">.</span> <span class="hs-varid">m</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">m</span> <span class="hs-varid">b</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">m</span> <span class="hs-varid">b</span>
<a name="line-47"></a>    <span class="hs-comment">-- | Sequentially compose two actions, discarding any value produced</span>
<a name="line-48"></a>    <span class="hs-comment">-- by the first, like sequencing operators (such as the semicolon)</span>
<a name="line-49"></a>    <span class="hs-comment">-- in imperative languages.</span>
<a name="line-50"></a>    <span class="hs-layout">(</span><span class="hs-varop">&gt;&gt;</span><span class="hs-layout">)</span>        <span class="hs-keyglyph">::</span> <span class="hs-keyword">forall</span> <span class="hs-varid">a</span> <span class="hs-varid">b</span><span class="hs-varop">.</span> <span class="hs-varid">m</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">m</span> <span class="hs-varid">b</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">m</span> <span class="hs-varid">b</span>
<a name="line-51"></a>        <span class="hs-comment">-- Explicit for-alls so that we know what order to</span>
<a name="line-52"></a>        <span class="hs-comment">-- give type arguments when desugaring</span>
<a name="line-53"></a>
<a name="line-54"></a>    <span class="hs-comment">-- | Inject a value into the monadic type.</span>
<a name="line-55"></a>    <span class="hs-varid">return</span>      <span class="hs-keyglyph">::</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">m</span> <span class="hs-varid">a</span>
<a name="line-56"></a>    <span class="hs-comment">-- | Fail with a message.  This operation is not part of the</span>
<a name="line-57"></a>    <span class="hs-comment">-- mathematical definition of a monad, but is invoked on pattern-match</span>
<a name="line-58"></a>    <span class="hs-comment">-- failure in a @do@ expression.</span>
<a name="line-59"></a>    <span class="hs-varid">fail</span>        <span class="hs-keyglyph">::</span> <span class="hs-conid">String</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">m</span> <span class="hs-varid">a</span>
<a name="line-60"></a>
<a name="line-61"></a>    <span class="hs-comment">{-# INLINE (&gt;&gt;) #-}</span>
<a name="line-62"></a>    <span class="hs-varid">m</span> <span class="hs-varop">&gt;&gt;</span> <span class="hs-varid">k</span>      <span class="hs-keyglyph">=</span> <span class="hs-varid">m</span> <span class="hs-varop">&gt;&gt;=</span> <span class="hs-keyglyph">\</span><span class="hs-keyword">_</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">k</span>
<a name="line-63"></a>    <span class="hs-varid">fail</span> <span class="hs-varid">s</span>      <span class="hs-keyglyph">=</span> <span class="hs-varid">error</span> <span class="hs-varid">s</span>
<a name="line-64"></a>
<a name="line-65"></a><a name="instance%20Functor%20((-%3e)%20r)"></a><span class="hs-keyword">instance</span> <span class="hs-conid">Functor</span> <span class="hs-layout">(</span><span class="hs-layout">(</span><span class="hs-keyglyph">-&gt;</span><span class="hs-layout">)</span> <span class="hs-varid">r</span><span class="hs-layout">)</span> <span class="hs-keyword">where</span>
<a name="line-66"></a>    <span class="hs-varid">fmap</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">(</span><span class="hs-varop">.</span><span class="hs-layout">)</span>
<a name="line-67"></a>
<a name="line-68"></a><a name="instance%20Monad%20((-%3e)%20r)"></a><span class="hs-keyword">instance</span> <span class="hs-conid">Monad</span> <span class="hs-layout">(</span><span class="hs-layout">(</span><span class="hs-keyglyph">-&gt;</span><span class="hs-layout">)</span> <span class="hs-varid">r</span><span class="hs-layout">)</span> <span class="hs-keyword">where</span>
<a name="line-69"></a>    <span class="hs-varid">return</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">const</span>
<a name="line-70"></a>    <span class="hs-varid">f</span> <span class="hs-varop">&gt;&gt;=</span> <span class="hs-varid">k</span> <span class="hs-keyglyph">=</span> <span class="hs-keyglyph">\</span> <span class="hs-varid">r</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">k</span> <span class="hs-layout">(</span><span class="hs-varid">f</span> <span class="hs-varid">r</span><span class="hs-layout">)</span> <span class="hs-varid">r</span>
<a name="line-71"></a>
<a name="line-72"></a><a name="instance%20Functor%20((,)%20a)"></a><span class="hs-keyword">instance</span> <span class="hs-conid">Functor</span> <span class="hs-layout">(</span><span class="hs-conid">(,)</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyword">where</span>
<a name="line-73"></a>    <span class="hs-varid">fmap</span> <span class="hs-varid">f</span> <span class="hs-layout">(</span><span class="hs-varid">x</span><span class="hs-layout">,</span><span class="hs-varid">y</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">(</span><span class="hs-varid">x</span><span class="hs-layout">,</span> <span class="hs-varid">f</span> <span class="hs-varid">y</span><span class="hs-layout">)</span>
</pre>\end{code}


%*********************************************************
%*                                                      *
\subsection{The list type}
%*                                                      *
%*********************************************************

\begin{code}
<pre><a name="line-1"></a><a name="instance%20Functor%20%5b%5d"></a><span class="hs-keyword">instance</span> <span class="hs-conid">Functor</span> <span class="hs-conid">[]</span> <span class="hs-keyword">where</span>
<a name="line-2"></a>    <span class="hs-varid">fmap</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">map</span>
<a name="line-3"></a>
<a name="line-4"></a><a name="instance%20Monad%20%5b%5d"></a><span class="hs-keyword">instance</span>  <span class="hs-conid">Monad</span> <span class="hs-conid">[]</span>  <span class="hs-keyword">where</span>
<a name="line-5"></a>    <span class="hs-varid">m</span> <span class="hs-varop">&gt;&gt;=</span> <span class="hs-varid">k</span>             <span class="hs-keyglyph">=</span> <span class="hs-varid">foldr</span> <span class="hs-layout">(</span><span class="hs-layout">(</span><span class="hs-varop">++</span><span class="hs-layout">)</span> <span class="hs-varop">.</span> <span class="hs-varid">k</span><span class="hs-layout">)</span> <span class="hs-conid">[]</span> <span class="hs-varid">m</span>
<a name="line-6"></a>    <span class="hs-varid">m</span> <span class="hs-varop">&gt;&gt;</span> <span class="hs-varid">k</span>              <span class="hs-keyglyph">=</span> <span class="hs-varid">foldr</span> <span class="hs-layout">(</span><span class="hs-layout">(</span><span class="hs-varop">++</span><span class="hs-layout">)</span> <span class="hs-varop">.</span> <span class="hs-layout">(</span><span class="hs-keyglyph">\</span> <span class="hs-keyword">_</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">k</span><span class="hs-layout">)</span><span class="hs-layout">)</span> <span class="hs-conid">[]</span> <span class="hs-varid">m</span>
<a name="line-7"></a>    <span class="hs-varid">return</span> <span class="hs-varid">x</span>            <span class="hs-keyglyph">=</span> <span class="hs-keyglyph">[</span><span class="hs-varid">x</span><span class="hs-keyglyph">]</span>
<a name="line-8"></a>    <span class="hs-varid">fail</span> <span class="hs-keyword">_</span>              <span class="hs-keyglyph">=</span> <span class="hs-conid">[]</span>
</pre>\end{code}

A few list functions that appear here because they are used here.
The rest of the prelude list functions are in GHC.List.

----------------------------------------------
--      foldr/build/augment
----------------------------------------------
  
\begin{code}
<pre><a name="line-1"></a><span class="hs-comment">-- | 'foldr', applied to a binary operator, a starting value (typically</span>
<a name="line-2"></a><span class="hs-comment">-- the right-identity of the operator), and a list, reduces the list</span>
<a name="line-3"></a><span class="hs-comment">-- using the binary operator, from right to left:</span>
<a name="line-4"></a><span class="hs-comment">--</span>
<a name="line-5"></a><span class="hs-comment">-- &gt; foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)</span>
<a name="line-6"></a>
<a name="line-7"></a><a name="foldr"></a><span class="hs-definition">foldr</span>            <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">b</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">b</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">b</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">b</span>
<a name="line-8"></a><span class="hs-comment">-- foldr _ z []     =  z</span>
<a name="line-9"></a><span class="hs-comment">-- foldr f z (x:xs) =  f x (foldr f z xs)</span>
<a name="line-10"></a><span class="hs-comment">{-# INLINE [0] foldr #-}</span>
<a name="line-11"></a><span class="hs-comment">-- Inline only in the final stage, after the foldr/cons rule has had a chance</span>
<a name="line-12"></a><span class="hs-comment">-- Also note that we inline it when it has *two* parameters, which are the </span>
<a name="line-13"></a><span class="hs-comment">-- ones we are keen about specialising!</span>
<a name="line-14"></a><span class="hs-definition">foldr</span> <span class="hs-varid">k</span> <span class="hs-varid">z</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">go</span>
<a name="line-15"></a>          <span class="hs-keyword">where</span>
<a name="line-16"></a>            <span class="hs-varid">go</span> <span class="hs-conid">[]</span>     <span class="hs-keyglyph">=</span> <span class="hs-varid">z</span>
<a name="line-17"></a>            <span class="hs-varid">go</span> <span class="hs-layout">(</span><span class="hs-varid">y</span><span class="hs-conop">:</span><span class="hs-varid">ys</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">y</span> <span class="hs-varop">`k`</span> <span class="hs-varid">go</span> <span class="hs-varid">ys</span>
<a name="line-18"></a>
<a name="line-19"></a><span class="hs-comment">-- | A list producer that can be fused with 'foldr'.</span>
<a name="line-20"></a><span class="hs-comment">-- This function is merely</span>
<a name="line-21"></a><span class="hs-comment">--</span>
<a name="line-22"></a><span class="hs-comment">-- &gt;    build g = g (:) []</span>
<a name="line-23"></a><span class="hs-comment">--</span>
<a name="line-24"></a><span class="hs-comment">-- but GHC's simplifier will transform an expression of the form</span>
<a name="line-25"></a><span class="hs-comment">-- @'foldr' k z ('build' g)@, which may arise after inlining, to @g k z@,</span>
<a name="line-26"></a><span class="hs-comment">-- which avoids producing an intermediate list.</span>
<a name="line-27"></a>
<a name="line-28"></a><a name="build"></a><span class="hs-definition">build</span>   <span class="hs-keyglyph">::</span> <span class="hs-keyword">forall</span> <span class="hs-varid">a</span><span class="hs-varop">.</span> <span class="hs-layout">(</span><span class="hs-keyword">forall</span> <span class="hs-varid">b</span><span class="hs-varop">.</span> <span class="hs-layout">(</span><span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">b</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">b</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">b</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">b</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span>
<a name="line-29"></a><span class="hs-comment">{-# INLINE [1] build #-}</span>
<a name="line-30"></a>        <span class="hs-comment">-- The INLINE is important, even though build is tiny,</span>
<a name="line-31"></a>        <span class="hs-comment">-- because it prevents [] getting inlined in the version that</span>
<a name="line-32"></a>        <span class="hs-comment">-- appears in the interface file.  If [] *is* inlined, it</span>
<a name="line-33"></a>        <span class="hs-comment">-- won't match with [] appearing in rules in an importing module.</span>
<a name="line-34"></a>        <span class="hs-comment">--</span>
<a name="line-35"></a>        <span class="hs-comment">-- The &quot;1&quot; says to inline in phase 1</span>
<a name="line-36"></a>
<a name="line-37"></a><span class="hs-definition">build</span> <span class="hs-varid">g</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">g</span> <span class="hs-layout">(</span><span class="hs-conop">:</span><span class="hs-layout">)</span> <span class="hs-conid">[]</span>
<a name="line-38"></a>
<a name="line-39"></a><span class="hs-comment">-- | A list producer that can be fused with 'foldr'.</span>
<a name="line-40"></a><span class="hs-comment">-- This function is merely</span>
<a name="line-41"></a><span class="hs-comment">--</span>
<a name="line-42"></a><span class="hs-comment">-- &gt;    augment g xs = g (:) xs</span>
<a name="line-43"></a><span class="hs-comment">--</span>
<a name="line-44"></a><span class="hs-comment">-- but GHC's simplifier will transform an expression of the form</span>
<a name="line-45"></a><span class="hs-comment">-- @'foldr' k z ('augment' g xs)@, which may arise after inlining, to</span>
<a name="line-46"></a><span class="hs-comment">-- @g k ('foldr' k z xs)@, which avoids producing an intermediate list.</span>
<a name="line-47"></a>
<a name="line-48"></a><a name="augment"></a><span class="hs-definition">augment</span> <span class="hs-keyglyph">::</span> <span class="hs-keyword">forall</span> <span class="hs-varid">a</span><span class="hs-varop">.</span> <span class="hs-layout">(</span><span class="hs-keyword">forall</span> <span class="hs-varid">b</span><span class="hs-varop">.</span> <span class="hs-layout">(</span><span class="hs-varid">a</span><span class="hs-keyglyph">-&gt;</span><span class="hs-varid">b</span><span class="hs-keyglyph">-&gt;</span><span class="hs-varid">b</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">b</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">b</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span>
<a name="line-49"></a><span class="hs-comment">{-# INLINE [1] augment #-}</span>
<a name="line-50"></a><span class="hs-definition">augment</span> <span class="hs-varid">g</span> <span class="hs-varid">xs</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">g</span> <span class="hs-layout">(</span><span class="hs-conop">:</span><span class="hs-layout">)</span> <span class="hs-varid">xs</span>
<a name="line-51"></a>
<a name="line-52"></a><span class="hs-comment">{-# RULES
<a name="line-53"></a>&quot;fold/build&quot;    forall k z (g::forall b. (a-&gt;b-&gt;b) -&gt; b -&gt; b) . 
<a name="line-54"></a>                foldr k z (build g) = g k z
<a name="line-55"></a>
<a name="line-56"></a>&quot;foldr/augment&quot; forall k z xs (g::forall b. (a-&gt;b-&gt;b) -&gt; b -&gt; b) . 
<a name="line-57"></a>                foldr k z (augment g xs) = g k (foldr k z xs)
<a name="line-58"></a>
<a name="line-59"></a>&quot;foldr/id&quot;                        foldr (:) [] = \x  -&gt; x
<a name="line-60"></a>&quot;foldr/app&quot;     [1] forall ys. foldr (:) ys = \xs -&gt; xs ++ ys
<a name="line-61"></a>        -- Only activate this from phase 1, because that's
<a name="line-62"></a>        -- when we disable the rule that expands (++) into foldr
<a name="line-63"></a>
<a name="line-64"></a>-- The foldr/cons rule looks nice, but it can give disastrously
<a name="line-65"></a>-- bloated code when commpiling
<a name="line-66"></a>--      array (a,b) [(1,2), (2,2), (3,2), ...very long list... ]
<a name="line-67"></a>-- i.e. when there are very very long literal lists
<a name="line-68"></a>-- So I've disabled it for now. We could have special cases
<a name="line-69"></a>-- for short lists, I suppose.
<a name="line-70"></a>-- &quot;foldr/cons&quot; forall k z x xs. foldr k z (x:xs) = k x (foldr k z xs)
<a name="line-71"></a>
<a name="line-72"></a>&quot;foldr/single&quot;  forall k z x. foldr k z [x] = k x z
<a name="line-73"></a>&quot;foldr/nil&quot;     forall k z.   foldr k z []  = z 
<a name="line-74"></a>
<a name="line-75"></a>&quot;augment/build&quot; forall (g::forall b. (a-&gt;b-&gt;b) -&gt; b -&gt; b)
<a name="line-76"></a>                       (h::forall b. (a-&gt;b-&gt;b) -&gt; b -&gt; b) .
<a name="line-77"></a>                       augment g (build h) = build (\c n -&gt; g c (h c n))
<a name="line-78"></a>&quot;augment/nil&quot;   forall (g::forall b. (a-&gt;b-&gt;b) -&gt; b -&gt; b) .
<a name="line-79"></a>                        augment g [] = build g
<a name="line-80"></a> #-}</span>
<a name="line-81"></a>
<a name="line-82"></a><span class="hs-comment">-- This rule is true, but not (I think) useful:</span>
<a name="line-83"></a><span class="hs-comment">--      augment g (augment h t) = augment (\cn -&gt; g c (h c n)) t</span>
</pre>\end{code}


----------------------------------------------
--              map     
----------------------------------------------

\begin{code}
<pre><a name="line-1"></a><span class="hs-comment">-- | 'map' @f xs@ is the list obtained by applying @f@ to each element</span>
<a name="line-2"></a><span class="hs-comment">-- of @xs@, i.e.,</span>
<a name="line-3"></a><span class="hs-comment">--</span>
<a name="line-4"></a><span class="hs-comment">-- &gt; map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]</span>
<a name="line-5"></a><span class="hs-comment">-- &gt; map f [x1, x2, ...] == [f x1, f x2, ...]</span>
<a name="line-6"></a>
<a name="line-7"></a><a name="map"></a><span class="hs-definition">map</span> <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">b</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyglyph">[</span><span class="hs-varid">b</span><span class="hs-keyglyph">]</span>
<a name="line-8"></a><span class="hs-definition">map</span> <span class="hs-keyword">_</span> <span class="hs-conid">[]</span>     <span class="hs-keyglyph">=</span> <span class="hs-conid">[]</span>
<a name="line-9"></a><span class="hs-definition">map</span> <span class="hs-varid">f</span> <span class="hs-layout">(</span><span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">xs</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">f</span> <span class="hs-varid">x</span> <span class="hs-conop">:</span> <span class="hs-varid">map</span> <span class="hs-varid">f</span> <span class="hs-varid">xs</span>
<a name="line-10"></a>
<a name="line-11"></a><a name="mapFB"></a><span class="hs-comment">-- Note eta expanded</span>
<a name="line-12"></a><span class="hs-definition">mapFB</span> <span class="hs-keyglyph">::</span>  <span class="hs-layout">(</span><span class="hs-varid">elt</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">lst</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">lst</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">elt</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">lst</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">lst</span>
<a name="line-13"></a><span class="hs-comment">{-# INLINE [0] mapFB #-}</span>
<a name="line-14"></a><span class="hs-definition">mapFB</span> <span class="hs-varid">c</span> <span class="hs-varid">f</span> <span class="hs-keyglyph">=</span> <span class="hs-keyglyph">\</span><span class="hs-varid">x</span> <span class="hs-varid">ys</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">c</span> <span class="hs-layout">(</span><span class="hs-varid">f</span> <span class="hs-varid">x</span><span class="hs-layout">)</span> <span class="hs-varid">ys</span>
<a name="line-15"></a>
<a name="line-16"></a><span class="hs-comment">-- The rules for map work like this.</span>
<a name="line-17"></a><span class="hs-comment">-- </span>
<a name="line-18"></a><span class="hs-comment">-- Up to (but not including) phase 1, we use the &quot;map&quot; rule to</span>
<a name="line-19"></a><span class="hs-comment">-- rewrite all saturated applications of map with its build/fold </span>
<a name="line-20"></a><span class="hs-comment">-- form, hoping for fusion to happen.</span>
<a name="line-21"></a><span class="hs-comment">-- In phase 1 and 0, we switch off that rule, inline build, and</span>
<a name="line-22"></a><span class="hs-comment">-- switch on the &quot;mapList&quot; rule, which rewrites the foldr/mapFB</span>
<a name="line-23"></a><span class="hs-comment">-- thing back into plain map.  </span>
<a name="line-24"></a><span class="hs-comment">--</span>
<a name="line-25"></a><span class="hs-comment">-- It's important that these two rules aren't both active at once </span>
<a name="line-26"></a><span class="hs-comment">-- (along with build's unfolding) else we'd get an infinite loop </span>
<a name="line-27"></a><span class="hs-comment">-- in the rules.  Hence the activation control below.</span>
<a name="line-28"></a><span class="hs-comment">--</span>
<a name="line-29"></a><span class="hs-comment">-- The &quot;mapFB&quot; rule optimises compositions of map.</span>
<a name="line-30"></a><span class="hs-comment">--</span>
<a name="line-31"></a><span class="hs-comment">-- This same pattern is followed by many other functions: </span>
<a name="line-32"></a><span class="hs-comment">-- e.g. append, filter, iterate, repeat, etc.</span>
<a name="line-33"></a>
<a name="line-34"></a><span class="hs-comment">{-# RULES
<a name="line-35"></a>&quot;map&quot;       [~1] forall f xs.   map f xs                = build (\c n -&gt; foldr (mapFB c f) n xs)
<a name="line-36"></a>&quot;mapList&quot;   [1]  forall f.      foldr (mapFB (:) f) []  = map f
<a name="line-37"></a>&quot;mapFB&quot;     forall c f g.       mapFB (mapFB c f) g     = mapFB c (f.g) 
<a name="line-38"></a>  #-}</span>
</pre>\end{code}


----------------------------------------------
--              append  
----------------------------------------------
\begin{code}
<pre><a name="line-1"></a><span class="hs-comment">-- | Append two lists, i.e.,</span>
<a name="line-2"></a><span class="hs-comment">--</span>
<a name="line-3"></a><span class="hs-comment">-- &gt; [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]</span>
<a name="line-4"></a><span class="hs-comment">-- &gt; [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]</span>
<a name="line-5"></a><span class="hs-comment">--</span>
<a name="line-6"></a><span class="hs-comment">-- If the first list is not finite, the result is the first list.</span>
<a name="line-7"></a>
<a name="line-8"></a><a name="++"></a><span class="hs-layout">(</span><span class="hs-varop">++</span><span class="hs-layout">)</span> <span class="hs-keyglyph">::</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span>
<a name="line-9"></a><span class="hs-layout">(</span><span class="hs-varop">++</span><span class="hs-layout">)</span> <span class="hs-conid">[]</span>     <span class="hs-varid">ys</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">ys</span>
<a name="line-10"></a><span class="hs-layout">(</span><span class="hs-varop">++</span><span class="hs-layout">)</span> <span class="hs-layout">(</span><span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">xs</span><span class="hs-layout">)</span> <span class="hs-varid">ys</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">x</span> <span class="hs-conop">:</span> <span class="hs-varid">xs</span> <span class="hs-varop">++</span> <span class="hs-varid">ys</span>
<a name="line-11"></a>
<a name="line-12"></a><span class="hs-comment">{-# RULES
<a name="line-13"></a>&quot;++&quot;    [~1] forall xs ys. xs ++ ys = augment (\c n -&gt; foldr c n xs) ys
<a name="line-14"></a>  #-}</span>
<a name="line-15"></a>
</pre>\end{code}


%*********************************************************
%*                                                      *
\subsection{Type @Bool@}
%*                                                      *
%*********************************************************

\begin{code}
<pre><a name="line-1"></a><a name="otherwise"></a><span class="hs-comment">-- |'otherwise' is defined as the value 'True'.  It helps to make</span>
<a name="line-2"></a><span class="hs-comment">-- guards more readable.  eg.</span>
<a name="line-3"></a><span class="hs-comment">--</span>
<a name="line-4"></a><span class="hs-comment">-- &gt;  f x | x &lt; 0     = ...</span>
<a name="line-5"></a><span class="hs-comment">-- &gt;      | otherwise = ...</span>
<a name="line-6"></a><span class="hs-definition">otherwise</span>               <span class="hs-keyglyph">::</span> <span class="hs-conid">Bool</span>
<a name="line-7"></a><span class="hs-definition">otherwise</span>               <span class="hs-keyglyph">=</span>  <span class="hs-conid">True</span>
</pre>\end{code}

%*********************************************************
%*                                                      *
\subsection{Type @Char@ and @String@}
%*                                                      *
%*********************************************************

\begin{code}
<pre><a name="line-1"></a><a name="String"></a><span class="hs-comment">-- | A 'String' is a list of characters.  String constants in Haskell are values</span>
<a name="line-2"></a><a name="String"></a><span class="hs-comment">-- of type 'String'.</span>
<a name="line-3"></a><a name="String"></a><span class="hs-comment">--</span>
<a name="line-4"></a><a name="String"></a><span class="hs-keyword">type</span> <span class="hs-conid">String</span> <span class="hs-keyglyph">=</span> <span class="hs-keyglyph">[</span><span class="hs-conid">Char</span><span class="hs-keyglyph">]</span>
<a name="line-5"></a>
<a name="line-6"></a><span class="hs-comment">{-# RULES
<a name="line-7"></a>&quot;x# `eqChar#` x#&quot; forall x#. x# `eqChar#` x# = True
<a name="line-8"></a>&quot;x# `neChar#` x#&quot; forall x#. x# `neChar#` x# = False
<a name="line-9"></a>&quot;x# `gtChar#` x#&quot; forall x#. x# `gtChar#` x# = False
<a name="line-10"></a>&quot;x# `geChar#` x#&quot; forall x#. x# `geChar#` x# = True
<a name="line-11"></a>&quot;x# `leChar#` x#&quot; forall x#. x# `leChar#` x# = True
<a name="line-12"></a>&quot;x# `ltChar#` x#&quot; forall x#. x# `ltChar#` x# = False
<a name="line-13"></a>  #-}</span>
<a name="line-14"></a>
<a name="line-15"></a><a name="unsafeChr"></a><span class="hs-definition">unsafeChr</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Char</span>
<a name="line-16"></a><span class="hs-definition">unsafeChr</span> <span class="hs-layout">(</span><span class="hs-conid">I</span><span class="hs-cpp">#</span> <span class="hs-varid">i</span><span class="hs-cpp">#</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">C</span><span class="hs-cpp">#</span> <span class="hs-layout">(</span><span class="hs-varid">chr</span><span class="hs-cpp">#</span> <span class="hs-varid">i</span><span class="hs-cpp">#</span><span class="hs-layout">)</span>
<a name="line-17"></a>
<a name="line-18"></a><a name="ord"></a><span class="hs-comment">-- | The 'Prelude.fromEnum' method restricted to the type 'Data.Char.Char'.</span>
<a name="line-19"></a><span class="hs-definition">ord</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Char</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span>
<a name="line-20"></a><span class="hs-definition">ord</span> <span class="hs-layout">(</span><span class="hs-conid">C</span><span class="hs-cpp">#</span> <span class="hs-varid">c</span><span class="hs-cpp">#</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">I</span><span class="hs-cpp">#</span> <span class="hs-layout">(</span><span class="hs-varid">ord</span><span class="hs-cpp">#</span> <span class="hs-varid">c</span><span class="hs-cpp">#</span><span class="hs-layout">)</span>
</pre>\end{code}

String equality is used when desugaring pattern-matches against strings.

\begin{code}
<pre><a name="line-1"></a><a name="eqString"></a><span class="hs-definition">eqString</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">String</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">String</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Bool</span>
<a name="line-2"></a><span class="hs-definition">eqString</span> <span class="hs-conid">[]</span>       <span class="hs-conid">[]</span>       <span class="hs-keyglyph">=</span> <span class="hs-conid">True</span>
<a name="line-3"></a><span class="hs-definition">eqString</span> <span class="hs-layout">(</span><span class="hs-varid">c1</span><span class="hs-conop">:</span><span class="hs-varid">cs1</span><span class="hs-layout">)</span> <span class="hs-layout">(</span><span class="hs-varid">c2</span><span class="hs-conop">:</span><span class="hs-varid">cs2</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">c1</span> <span class="hs-varop">==</span> <span class="hs-varid">c2</span> <span class="hs-varop">&amp;&amp;</span> <span class="hs-varid">cs1</span> <span class="hs-varop">`eqString`</span> <span class="hs-varid">cs2</span>
<a name="line-4"></a><span class="hs-definition">eqString</span> <span class="hs-keyword">_</span>        <span class="hs-keyword">_</span>        <span class="hs-keyglyph">=</span> <span class="hs-conid">False</span>
<a name="line-5"></a>
<a name="line-6"></a><span class="hs-comment">{-# RULES &quot;eqString&quot; (==) = eqString #-}</span>
<a name="line-7"></a><span class="hs-comment">-- eqString also has a BuiltInRule in PrelRules.lhs:</span>
<a name="line-8"></a><span class="hs-comment">--      eqString (unpackCString# (Lit s1)) (unpackCString# (Lit s2) = s1==s2</span>
</pre>\end{code}


%*********************************************************
%*                                                      *
\subsection{Type @Int@}
%*                                                      *
%*********************************************************

\begin{code}
<pre><a name="line-1"></a><a name="maxInt"></a><span class="hs-definition">maxInt</span><span class="hs-layout">,</span> <span class="hs-varid">minInt</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int</span>
<a name="line-2"></a>
<a name="line-3"></a><span class="hs-comment">{- Seems clumsy. Should perhaps put minInt and MaxInt directly into MachDeps.h -}</span>
<a name="line-4"></a><span class="hs-cpp">#if WORD_SIZE_IN_BITS == 31</span>
<a name="line-5"></a><a name="minInt"></a><span class="hs-definition">minInt</span>  <span class="hs-keyglyph">=</span> <span class="hs-conid">I</span><span class="hs-cpp">#</span> <span class="hs-layout">(</span><span class="hs-comment">-</span><span class="hs-num">0x40000000</span><span class="hs-cpp">#</span><span class="hs-layout">)</span>
<a name="line-6"></a><span class="hs-definition">maxInt</span>  <span class="hs-keyglyph">=</span> <span class="hs-conid">I</span><span class="hs-cpp">#</span> <span class="hs-num">0x3FFFFFFF</span><span class="hs-cpp">#</span>
<a name="line-7"></a><span class="hs-cpp">#elif WORD_SIZE_IN_BITS == 32</span>
<a name="line-8"></a><span class="hs-definition">minInt</span>  <span class="hs-keyglyph">=</span> <span class="hs-conid">I</span><span class="hs-cpp">#</span> <span class="hs-layout">(</span><span class="hs-comment">-</span><span class="hs-num">0x80000000</span><span class="hs-cpp">#</span><span class="hs-layout">)</span>
<a name="line-9"></a><span class="hs-definition">maxInt</span>  <span class="hs-keyglyph">=</span> <span class="hs-conid">I</span><span class="hs-cpp">#</span> <span class="hs-num">0x7FFFFFFF</span><span class="hs-cpp">#</span>
<a name="line-10"></a><span class="hs-cpp">#else </span>
<a name="line-11"></a><span class="hs-definition">minInt</span>  <span class="hs-keyglyph">=</span> <span class="hs-conid">I</span><span class="hs-cpp">#</span> <span class="hs-layout">(</span><span class="hs-comment">-</span><span class="hs-num">0x8000000000000000</span><span class="hs-cpp">#</span><span class="hs-layout">)</span>
<a name="line-12"></a><span class="hs-definition">maxInt</span>  <span class="hs-keyglyph">=</span> <span class="hs-conid">I</span><span class="hs-cpp">#</span> <span class="hs-num">0x7FFFFFFFFFFFFFFF</span><span class="hs-cpp">#</span>
<a name="line-13"></a><span class="hs-cpp">#endif</span>
</pre>\end{code}


%*********************************************************
%*                                                      *
\subsection{The function type}
%*                                                      *
%*********************************************************

\begin{code}
<pre><a name="line-1"></a><a name="id"></a><span class="hs-comment">-- | Identity function.</span>
<a name="line-2"></a><span class="hs-definition">id</span>                      <span class="hs-keyglyph">::</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span>
<a name="line-3"></a><span class="hs-definition">id</span> <span class="hs-varid">x</span>                    <span class="hs-keyglyph">=</span>  <span class="hs-varid">x</span>
<a name="line-4"></a>
<a name="line-5"></a><a name="lazy"></a><span class="hs-comment">-- | The call '(lazy e)' means the same as 'e', but 'lazy' has a </span>
<a name="line-6"></a><span class="hs-comment">-- magical strictness property: it is lazy in its first argument, </span>
<a name="line-7"></a><span class="hs-comment">-- even though its semantics is strict.</span>
<a name="line-8"></a><span class="hs-definition">lazy</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span>
<a name="line-9"></a><span class="hs-definition">lazy</span> <span class="hs-varid">x</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">x</span>
<a name="line-10"></a><span class="hs-comment">-- Implementation note: its strictness and unfolding are over-ridden</span>
<a name="line-11"></a><span class="hs-comment">-- by the definition in MkId.lhs; in both cases to nothing at all.</span>
<a name="line-12"></a><span class="hs-comment">-- That way, 'lazy' does not get inlined, and the strictness analyser</span>
<a name="line-13"></a><span class="hs-comment">-- sees it as lazy.  Then the worker/wrapper phase inlines it.</span>
<a name="line-14"></a><span class="hs-comment">-- Result: happiness</span>
<a name="line-15"></a>
<a name="line-16"></a><span class="hs-comment">-- Assertion function.  This simply ignores its boolean argument.</span>
<a name="line-17"></a><span class="hs-comment">-- The compiler may rewrite it to @('assertError' line)@.</span>
<a name="line-18"></a>
<a name="line-19"></a><span class="hs-comment">-- | If the first argument evaluates to 'True', then the result is the</span>
<a name="line-20"></a><span class="hs-comment">-- second argument.  Otherwise an 'AssertionFailed' exception is raised,</span>
<a name="line-21"></a><span class="hs-comment">-- containing a 'String' with the source file and line number of the</span>
<a name="line-22"></a><span class="hs-comment">-- call to 'assert'.</span>
<a name="line-23"></a><span class="hs-comment">--</span>
<a name="line-24"></a><span class="hs-comment">-- Assertions can normally be turned on or off with a compiler flag</span>
<a name="line-25"></a><span class="hs-comment">-- (for GHC, assertions are normally on unless optimisation is turned on </span>
<a name="line-26"></a><span class="hs-comment">-- with @-O@ or the @-fignore-asserts@</span>
<a name="line-27"></a><span class="hs-comment">-- option is given).  When assertions are turned off, the first</span>
<a name="line-28"></a><span class="hs-comment">-- argument to 'assert' is ignored, and the second argument is</span>
<a name="line-29"></a><span class="hs-comment">-- returned as the result.</span>
<a name="line-30"></a>
<a name="line-31"></a><a name="assert"></a><span class="hs-comment">--      SLPJ: in 5.04 etc 'assert' is in GHC.Prim,</span>
<a name="line-32"></a><span class="hs-comment">--      but from Template Haskell onwards it's simply</span>
<a name="line-33"></a><span class="hs-comment">--      defined here in Base.lhs</span>
<a name="line-34"></a><span class="hs-definition">assert</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Bool</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span>
<a name="line-35"></a><span class="hs-definition">assert</span> <span class="hs-sel">_pred</span> <span class="hs-varid">r</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">r</span>
<a name="line-36"></a>
<a name="line-37"></a><a name="breakpoint"></a><span class="hs-definition">breakpoint</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span>
<a name="line-38"></a><span class="hs-definition">breakpoint</span> <span class="hs-varid">r</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">r</span>
<a name="line-39"></a>
<a name="line-40"></a><a name="breakpointCond"></a><span class="hs-definition">breakpointCond</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Bool</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span>
<a name="line-41"></a><span class="hs-definition">breakpointCond</span> <span class="hs-keyword">_</span> <span class="hs-varid">r</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">r</span>
<a name="line-42"></a>
<a name="line-43"></a><a name="Opaque"></a><span class="hs-keyword">data</span> <span class="hs-conid">Opaque</span> <span class="hs-keyglyph">=</span> <span class="hs-keyword">forall</span> <span class="hs-varid">a</span><span class="hs-varop">.</span> <span class="hs-conid">O</span> <span class="hs-varid">a</span>
<a name="line-44"></a>
<a name="line-45"></a><a name="const"></a><span class="hs-comment">-- | Constant function.</span>
<a name="line-46"></a><span class="hs-definition">const</span>                   <span class="hs-keyglyph">::</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">b</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span>
<a name="line-47"></a><span class="hs-definition">const</span> <span class="hs-varid">x</span> <span class="hs-keyword">_</span>               <span class="hs-keyglyph">=</span>  <span class="hs-varid">x</span>
<a name="line-48"></a>
<a name="line-49"></a><a name="."></a><span class="hs-comment">-- | Function composition.</span>
<a name="line-50"></a><span class="hs-comment">{-# INLINE (.) #-}</span>
<a name="line-51"></a><span class="hs-comment">-- Make sure it has TWO args only on the left, so that it inlines</span>
<a name="line-52"></a><span class="hs-comment">-- when applied to two functions, even if there is no final argument</span>
<a name="line-53"></a><span class="hs-layout">(</span><span class="hs-varop">.</span><span class="hs-layout">)</span>    <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-varid">b</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">c</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">b</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">c</span>
<a name="line-54"></a><span class="hs-layout">(</span><span class="hs-varop">.</span><span class="hs-layout">)</span> <span class="hs-varid">f</span> <span class="hs-varid">g</span> <span class="hs-keyglyph">=</span> <span class="hs-keyglyph">\</span><span class="hs-varid">x</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">f</span> <span class="hs-layout">(</span><span class="hs-varid">g</span> <span class="hs-varid">x</span><span class="hs-layout">)</span>
<a name="line-55"></a>
<a name="line-56"></a><a name="flip"></a><span class="hs-comment">-- | @'flip' f@ takes its (first) two arguments in the reverse order of @f@.</span>
<a name="line-57"></a><span class="hs-definition">flip</span>                    <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">b</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">c</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">b</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">c</span>
<a name="line-58"></a><span class="hs-definition">flip</span> <span class="hs-varid">f</span> <span class="hs-varid">x</span> <span class="hs-varid">y</span>              <span class="hs-keyglyph">=</span>  <span class="hs-varid">f</span> <span class="hs-varid">y</span> <span class="hs-varid">x</span>
<a name="line-59"></a>
<a name="line-60"></a><a name="$"></a><span class="hs-comment">-- | Application operator.  This operator is redundant, since ordinary</span>
<a name="line-61"></a><span class="hs-comment">-- application @(f x)@ means the same as @(f '$' x)@. However, '$' has</span>
<a name="line-62"></a><span class="hs-comment">-- low, right-associative binding precedence, so it sometimes allows</span>
<a name="line-63"></a><span class="hs-comment">-- parentheses to be omitted; for example:</span>
<a name="line-64"></a><span class="hs-comment">--</span>
<a name="line-65"></a><span class="hs-comment">-- &gt;     f $ g $ h x  =  f (g (h x))</span>
<a name="line-66"></a><span class="hs-comment">--</span>
<a name="line-67"></a><span class="hs-comment">-- It is also useful in higher-order situations, such as @'map' ('$' 0) xs@,</span>
<a name="line-68"></a><span class="hs-comment">-- or @'Data.List.zipWith' ('$') fs xs@.</span>
<a name="line-69"></a><span class="hs-comment">{-# INLINE ($) #-}</span>
<a name="line-70"></a><span class="hs-layout">(</span><span class="hs-varop">$</span><span class="hs-layout">)</span>                     <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">b</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">b</span>
<a name="line-71"></a><a name="f"></a><span class="hs-definition">f</span> <span class="hs-varop">$</span> <span class="hs-varid">x</span>                   <span class="hs-keyglyph">=</span>  <span class="hs-varid">f</span> <span class="hs-varid">x</span>
<a name="line-72"></a>
<a name="line-73"></a><a name="until"></a><span class="hs-comment">-- | @'until' p f@ yields the result of applying @f@ until @p@ holds.</span>
<a name="line-74"></a><span class="hs-definition">until</span>                   <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Bool</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span>
<a name="line-75"></a><span class="hs-definition">until</span> <span class="hs-varid">p</span> <span class="hs-varid">f</span> <span class="hs-varid">x</span> <span class="hs-keyglyph">|</span> <span class="hs-varid">p</span> <span class="hs-varid">x</span>       <span class="hs-keyglyph">=</span>  <span class="hs-varid">x</span>
<a name="line-76"></a>            <span class="hs-keyglyph">|</span> <span class="hs-varid">otherwise</span> <span class="hs-keyglyph">=</span>  <span class="hs-varid">until</span> <span class="hs-varid">p</span> <span class="hs-varid">f</span> <span class="hs-layout">(</span><span class="hs-varid">f</span> <span class="hs-varid">x</span><span class="hs-layout">)</span>
<a name="line-77"></a>
<a name="line-78"></a><a name="asTypeOf"></a><span class="hs-comment">-- | 'asTypeOf' is a type-restricted version of 'const'.  It is usually</span>
<a name="line-79"></a><span class="hs-comment">-- used as an infix operator, and its typing forces its first argument</span>
<a name="line-80"></a><span class="hs-comment">-- (which is usually overloaded) to have the same type as the second.</span>
<a name="line-81"></a><span class="hs-definition">asTypeOf</span>                <span class="hs-keyglyph">::</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span>
<a name="line-82"></a><span class="hs-definition">asTypeOf</span>                <span class="hs-keyglyph">=</span>  <span class="hs-varid">const</span>
</pre>\end{code}

%*********************************************************
%*                                                      *
\subsection{@Functor@ and @Monad@ instances for @IO@}
%*                                                      *
%*********************************************************

\begin{code}
<pre><a name="line-1"></a><a name="instance%20Functor%20IO"></a><span class="hs-keyword">instance</span>  <span class="hs-conid">Functor</span> <span class="hs-conid">IO</span> <span class="hs-keyword">where</span>
<a name="line-2"></a>   <span class="hs-varid">fmap</span> <span class="hs-varid">f</span> <span class="hs-varid">x</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">x</span> <span class="hs-varop">&gt;&gt;=</span> <span class="hs-layout">(</span><span class="hs-varid">return</span> <span class="hs-varop">.</span> <span class="hs-varid">f</span><span class="hs-layout">)</span>
<a name="line-3"></a>
<a name="line-4"></a><a name="instance%20Monad%20IO"></a><span class="hs-keyword">instance</span>  <span class="hs-conid">Monad</span> <span class="hs-conid">IO</span>  <span class="hs-keyword">where</span>
<a name="line-5"></a>    <span class="hs-comment">{-# INLINE return #-}</span>
<a name="line-6"></a>    <span class="hs-comment">{-# INLINE (&gt;&gt;)   #-}</span>
<a name="line-7"></a>    <span class="hs-comment">{-# INLINE (&gt;&gt;=)  #-}</span>
<a name="line-8"></a>    <span class="hs-varid">m</span> <span class="hs-varop">&gt;&gt;</span> <span class="hs-varid">k</span>    <span class="hs-keyglyph">=</span> <span class="hs-varid">m</span> <span class="hs-varop">&gt;&gt;=</span> <span class="hs-keyglyph">\</span> <span class="hs-keyword">_</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">k</span>
<a name="line-9"></a>    <span class="hs-varid">return</span>    <span class="hs-keyglyph">=</span> <span class="hs-varid">returnIO</span>
<a name="line-10"></a>    <span class="hs-layout">(</span><span class="hs-varop">&gt;&gt;=</span><span class="hs-layout">)</span>     <span class="hs-keyglyph">=</span> <span class="hs-varid">bindIO</span>
<a name="line-11"></a>    <span class="hs-varid">fail</span> <span class="hs-varid">s</span>    <span class="hs-keyglyph">=</span> <span class="hs-varid">failIO</span> <span class="hs-varid">s</span>
<a name="line-12"></a>
<a name="line-13"></a><a name="returnIO"></a><span class="hs-definition">returnIO</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">IO</span> <span class="hs-varid">a</span>
<a name="line-14"></a><span class="hs-definition">returnIO</span> <span class="hs-varid">x</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">IO</span> <span class="hs-varop">$</span> <span class="hs-keyglyph">\</span> <span class="hs-varid">s</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-cpp">#</span> <span class="hs-varid">s</span><span class="hs-layout">,</span> <span class="hs-varid">x</span> <span class="hs-cpp">#</span><span class="hs-layout">)</span>
<a name="line-15"></a>
<a name="line-16"></a><a name="bindIO"></a><span class="hs-definition">bindIO</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">IO</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">IO</span> <span class="hs-varid">b</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">IO</span> <span class="hs-varid">b</span>
<a name="line-17"></a><span class="hs-definition">bindIO</span> <span class="hs-layout">(</span><span class="hs-conid">IO</span> <span class="hs-varid">m</span><span class="hs-layout">)</span> <span class="hs-varid">k</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">IO</span> <span class="hs-varop">$</span> <span class="hs-keyglyph">\</span> <span class="hs-varid">s</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyword">case</span> <span class="hs-varid">m</span> <span class="hs-varid">s</span> <span class="hs-keyword">of</span> <span class="hs-layout">(</span><span class="hs-cpp">#</span> <span class="hs-varid">new_s</span><span class="hs-layout">,</span> <span class="hs-varid">a</span> <span class="hs-cpp">#</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">unIO</span> <span class="hs-layout">(</span><span class="hs-varid">k</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-varid">new_s</span>
<a name="line-18"></a>
<a name="line-19"></a><a name="thenIO"></a><span class="hs-definition">thenIO</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">IO</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">IO</span> <span class="hs-varid">b</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">IO</span> <span class="hs-varid">b</span>
<a name="line-20"></a><span class="hs-definition">thenIO</span> <span class="hs-layout">(</span><span class="hs-conid">IO</span> <span class="hs-varid">m</span><span class="hs-layout">)</span> <span class="hs-varid">k</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">IO</span> <span class="hs-varop">$</span> <span class="hs-keyglyph">\</span> <span class="hs-varid">s</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyword">case</span> <span class="hs-varid">m</span> <span class="hs-varid">s</span> <span class="hs-keyword">of</span> <span class="hs-layout">(</span><span class="hs-cpp">#</span> <span class="hs-varid">new_s</span><span class="hs-layout">,</span> <span class="hs-keyword">_</span> <span class="hs-cpp">#</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">unIO</span> <span class="hs-varid">k</span> <span class="hs-varid">new_s</span>
<a name="line-21"></a>
<a name="line-22"></a><a name="unIO"></a><span class="hs-definition">unIO</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">IO</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-conid">State</span><span class="hs-cpp">#</span> <span class="hs-conid">RealWorld</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-cpp">#</span> <span class="hs-conid">State</span><span class="hs-cpp">#</span> <span class="hs-conid">RealWorld</span><span class="hs-layout">,</span> <span class="hs-varid">a</span> <span class="hs-cpp">#</span><span class="hs-layout">)</span><span class="hs-layout">)</span>
<a name="line-23"></a><span class="hs-definition">unIO</span> <span class="hs-layout">(</span><span class="hs-conid">IO</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">a</span>
</pre>\end{code}

%*********************************************************
%*                                                      *
\subsection{@getTag@}
%*                                                      *
%*********************************************************

Returns the 'tag' of a constructor application; this function is used
by the deriving code for Eq, Ord and Enum.

The primitive dataToTag# requires an evaluated constructor application
as its argument, so we provide getTag as a wrapper that performs the
evaluation before calling dataToTag#.  We could have dataToTag#
evaluate its argument, but we prefer to do it this way because (a)
dataToTag# can be an inline primop if it doesn't need to do any
evaluation, and (b) we want to expose the evaluation to the
simplifier, because it might be possible to eliminate the evaluation
in the case when the argument is already known to be evaluated.

\begin{code}
<pre><a name="line-1"></a><a name="getTag"></a><span class="hs-comment">{-# INLINE getTag #-}</span>
<a name="line-2"></a><span class="hs-definition">getTag</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span><span class="hs-cpp">#</span>
<a name="line-3"></a><span class="hs-definition">getTag</span> <span class="hs-varid">x</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">x</span> <span class="hs-varop">`seq`</span> <span class="hs-varid">dataToTag</span><span class="hs-cpp">#</span> <span class="hs-varid">x</span>
</pre>\end{code}

%*********************************************************
%*                                                      *
\subsection{Numeric primops}
%*                                                      *
%*********************************************************

Definitions of the boxed PrimOps; these will be
used in the case of partial applications, etc.

\begin{code}
<pre><a name="line-1"></a><span class="hs-comment">{-# INLINE quotInt #-}</span>
<a name="line-2"></a><span class="hs-comment">{-# INLINE remInt #-}</span>
<a name="line-3"></a>
<a name="line-4"></a><a name="quotInt"></a><span class="hs-definition">quotInt</span><span class="hs-layout">,</span> <span class="hs-varid">remInt</span><span class="hs-layout">,</span> <span class="hs-varid">divInt</span><span class="hs-layout">,</span> <span class="hs-varid">modInt</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span>
<a name="line-5"></a><a name="quotInt"></a><span class="hs-layout">(</span><span class="hs-conid">I</span><span class="hs-cpp">#</span> <span class="hs-varid">x</span><span class="hs-layout">)</span> <span class="hs-varop">`quotInt`</span>  <span class="hs-layout">(</span><span class="hs-conid">I</span><span class="hs-cpp">#</span> <span class="hs-varid">y</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">I</span><span class="hs-cpp">#</span> <span class="hs-layout">(</span><span class="hs-varid">x</span> <span class="hs-varop">`</span><span class="hs-varid">quotInt</span><span class="hs-cpp">#</span><span class="hs-varop">`</span> <span class="hs-varid">y</span><span class="hs-layout">)</span>
<a name="line-6"></a><a name="remInt"></a><span class="hs-layout">(</span><span class="hs-conid">I</span><span class="hs-cpp">#</span> <span class="hs-varid">x</span><span class="hs-layout">)</span> <span class="hs-varop">`remInt`</span>   <span class="hs-layout">(</span><span class="hs-conid">I</span><span class="hs-cpp">#</span> <span class="hs-varid">y</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">I</span><span class="hs-cpp">#</span> <span class="hs-layout">(</span><span class="hs-varid">x</span> <span class="hs-varop">`</span><span class="hs-varid">remInt</span><span class="hs-cpp">#</span><span class="hs-varop">`</span>  <span class="hs-varid">y</span><span class="hs-layout">)</span>
<a name="line-7"></a><a name="divInt"></a><span class="hs-layout">(</span><span class="hs-conid">I</span><span class="hs-cpp">#</span> <span class="hs-varid">x</span><span class="hs-layout">)</span> <span class="hs-varop">`divInt`</span>   <span class="hs-layout">(</span><span class="hs-conid">I</span><span class="hs-cpp">#</span> <span class="hs-varid">y</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">I</span><span class="hs-cpp">#</span> <span class="hs-layout">(</span><span class="hs-varid">x</span> <span class="hs-varop">`</span><span class="hs-varid">divInt</span><span class="hs-cpp">#</span><span class="hs-varop">`</span>  <span class="hs-varid">y</span><span class="hs-layout">)</span>
<a name="line-8"></a><a name="modInt"></a><span class="hs-layout">(</span><span class="hs-conid">I</span><span class="hs-cpp">#</span> <span class="hs-varid">x</span><span class="hs-layout">)</span> <span class="hs-varop">`modInt`</span>   <span class="hs-layout">(</span><span class="hs-conid">I</span><span class="hs-cpp">#</span> <span class="hs-varid">y</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">I</span><span class="hs-cpp">#</span> <span class="hs-layout">(</span><span class="hs-varid">x</span> <span class="hs-varop">`</span><span class="hs-varid">modInt</span><span class="hs-cpp">#</span><span class="hs-varop">`</span>  <span class="hs-varid">y</span><span class="hs-layout">)</span>
<a name="line-9"></a>
<a name="line-10"></a><a name="quotRemInt"></a><span class="hs-definition">quotRemInt</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-conid">Int</span><span class="hs-layout">,</span> <span class="hs-conid">Int</span><span class="hs-layout">)</span>
<a name="line-11"></a><a name="quotRemInt"></a><span class="hs-layout">(</span><span class="hs-conid">I</span><span class="hs-cpp">#</span> <span class="hs-varid">x</span><span class="hs-layout">)</span> <span class="hs-varop">`quotRemInt`</span> <span class="hs-layout">(</span><span class="hs-conid">I</span><span class="hs-cpp">#</span> <span class="hs-varid">y</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-keyword">case</span> <span class="hs-varid">x</span> <span class="hs-varop">`</span><span class="hs-varid">quotRemInt</span><span class="hs-cpp">#</span><span class="hs-varop">`</span> <span class="hs-varid">y</span> <span class="hs-keyword">of</span>
<a name="line-12"></a>                             <span class="hs-layout">(</span><span class="hs-cpp">#</span> <span class="hs-varid">q</span><span class="hs-layout">,</span> <span class="hs-varid">r</span> <span class="hs-cpp">#</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span>
<a name="line-13"></a>                                 <span class="hs-layout">(</span><span class="hs-conid">I</span><span class="hs-cpp">#</span> <span class="hs-varid">q</span><span class="hs-layout">,</span> <span class="hs-conid">I</span><span class="hs-cpp">#</span> <span class="hs-varid">r</span><span class="hs-layout">)</span>
<a name="line-14"></a>
<a name="line-15"></a><a name="divModInt"></a><span class="hs-definition">divModInt</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-conid">Int</span><span class="hs-layout">,</span> <span class="hs-conid">Int</span><span class="hs-layout">)</span>
<a name="line-16"></a><a name="divModInt"></a><span class="hs-layout">(</span><span class="hs-conid">I</span><span class="hs-cpp">#</span> <span class="hs-varid">x</span><span class="hs-layout">)</span> <span class="hs-varop">`divModInt`</span> <span class="hs-layout">(</span><span class="hs-conid">I</span><span class="hs-cpp">#</span> <span class="hs-varid">y</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-keyword">case</span> <span class="hs-varid">x</span> <span class="hs-varop">`</span><span class="hs-varid">divModInt</span><span class="hs-cpp">#</span><span class="hs-varop">`</span> <span class="hs-varid">y</span> <span class="hs-keyword">of</span>
<a name="line-17"></a>                            <span class="hs-layout">(</span><span class="hs-cpp">#</span> <span class="hs-varid">q</span><span class="hs-layout">,</span> <span class="hs-varid">r</span> <span class="hs-cpp">#</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-conid">I</span><span class="hs-cpp">#</span> <span class="hs-varid">q</span><span class="hs-layout">,</span> <span class="hs-conid">I</span><span class="hs-cpp">#</span> <span class="hs-varid">r</span><span class="hs-layout">)</span>
<a name="line-18"></a>
<a name="line-19"></a><span class="hs-definition">divModInt</span><span class="hs-cpp">#</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int</span><span class="hs-cpp">#</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span><span class="hs-cpp">#</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-cpp">#</span> <span class="hs-conid">Int</span><span class="hs-cpp">#</span><span class="hs-layout">,</span> <span class="hs-conid">Int</span><span class="hs-cpp">#</span> <span class="hs-cpp">#</span><span class="hs-layout">)</span>
<a name="line-20"></a><a name="x"></a><span class="hs-definition">x</span><span class="hs-cpp">#</span> <span class="hs-varop">`</span><span class="hs-varid">divModInt</span><span class="hs-cpp">#</span><span class="hs-varop">`</span> <span class="hs-varid">y</span><span class="hs-cpp">#</span>
<a name="line-21"></a> <span class="hs-keyglyph">|</span> <span class="hs-layout">(</span><span class="hs-varid">x</span><span class="hs-cpp">#</span> <span class="hs-varop">&gt;#</span> <span class="hs-num">0</span><span class="hs-cpp">#</span><span class="hs-layout">)</span> <span class="hs-varop">&amp;&amp;</span> <span class="hs-layout">(</span><span class="hs-varid">y</span><span class="hs-cpp">#</span> <span class="hs-varop">&lt;#</span> <span class="hs-num">0</span><span class="hs-cpp">#</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-keyword">case</span> <span class="hs-layout">(</span><span class="hs-varid">x</span><span class="hs-cpp">#</span> <span class="hs-varop">-#</span> <span class="hs-num">1</span><span class="hs-cpp">#</span><span class="hs-layout">)</span> <span class="hs-varop">`</span><span class="hs-varid">quotRemInt</span><span class="hs-cpp">#</span><span class="hs-varop">`</span> <span class="hs-varid">y</span><span class="hs-cpp">#</span> <span class="hs-keyword">of</span>
<a name="line-22"></a>                              <span class="hs-layout">(</span><span class="hs-cpp">#</span> <span class="hs-varid">q</span><span class="hs-layout">,</span> <span class="hs-varid">r</span> <span class="hs-cpp">#</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-cpp">#</span> <span class="hs-varid">q</span> <span class="hs-varop">-#</span> <span class="hs-num">1</span><span class="hs-cpp">#</span><span class="hs-layout">,</span> <span class="hs-varid">r</span> <span class="hs-varop">+#</span> <span class="hs-varid">y</span><span class="hs-cpp">#</span> <span class="hs-varop">+#</span> <span class="hs-num">1</span><span class="hs-cpp">#</span> <span class="hs-cpp">#</span><span class="hs-layout">)</span>
<a name="line-23"></a> <span class="hs-keyglyph">|</span> <span class="hs-layout">(</span><span class="hs-varid">x</span><span class="hs-cpp">#</span> <span class="hs-varop">&lt;#</span> <span class="hs-num">0</span><span class="hs-cpp">#</span><span class="hs-layout">)</span> <span class="hs-varop">&amp;&amp;</span> <span class="hs-layout">(</span><span class="hs-varid">y</span><span class="hs-cpp">#</span> <span class="hs-varop">&gt;#</span> <span class="hs-num">0</span><span class="hs-cpp">#</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-keyword">case</span> <span class="hs-layout">(</span><span class="hs-varid">x</span><span class="hs-cpp">#</span> <span class="hs-varop">+#</span> <span class="hs-num">1</span><span class="hs-cpp">#</span><span class="hs-layout">)</span> <span class="hs-varop">`</span><span class="hs-varid">quotRemInt</span><span class="hs-cpp">#</span><span class="hs-varop">`</span> <span class="hs-varid">y</span><span class="hs-cpp">#</span> <span class="hs-keyword">of</span>
<a name="line-24"></a>                              <span class="hs-layout">(</span><span class="hs-cpp">#</span> <span class="hs-varid">q</span><span class="hs-layout">,</span> <span class="hs-varid">r</span> <span class="hs-cpp">#</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-cpp">#</span> <span class="hs-varid">q</span> <span class="hs-varop">-#</span> <span class="hs-num">1</span><span class="hs-cpp">#</span><span class="hs-layout">,</span> <span class="hs-varid">r</span> <span class="hs-varop">+#</span> <span class="hs-varid">y</span><span class="hs-cpp">#</span> <span class="hs-varop">-#</span> <span class="hs-num">1</span><span class="hs-cpp">#</span> <span class="hs-cpp">#</span><span class="hs-layout">)</span>
<a name="line-25"></a> <span class="hs-keyglyph">|</span> <span class="hs-varid">otherwise</span>                <span class="hs-keyglyph">=</span> <span class="hs-varid">x</span><span class="hs-cpp">#</span> <span class="hs-varop">`</span><span class="hs-varid">quotRemInt</span><span class="hs-cpp">#</span><span class="hs-varop">`</span> <span class="hs-varid">y</span><span class="hs-cpp">#</span>
<a name="line-26"></a>
<a name="line-27"></a><span class="hs-comment">{-# RULES
<a name="line-28"></a>&quot;x# +# 0#&quot; forall x#. x# +# 0# = x#
<a name="line-29"></a>&quot;0# +# x#&quot; forall x#. 0# +# x# = x#
<a name="line-30"></a>&quot;x# -# 0#&quot; forall x#. x# -# 0# = x#
<a name="line-31"></a>&quot;x# -# x#&quot; forall x#. x# -# x# = 0#
<a name="line-32"></a>&quot;x# *# 0#&quot; forall x#. x# *# 0# = 0#
<a name="line-33"></a>&quot;0# *# x#&quot; forall x#. 0# *# x# = 0#
<a name="line-34"></a>&quot;x# *# 1#&quot; forall x#. x# *# 1# = x#
<a name="line-35"></a>&quot;1# *# x#&quot; forall x#. 1# *# x# = x#
<a name="line-36"></a>  #-}</span>
<a name="line-37"></a>
<a name="line-38"></a><span class="hs-comment">{-# RULES
<a name="line-39"></a>&quot;x# &gt;# x#&quot;  forall x#. x# &gt;#  x# = False
<a name="line-40"></a>&quot;x# &gt;=# x#&quot; forall x#. x# &gt;=# x# = True
<a name="line-41"></a>&quot;x# ==# x#&quot; forall x#. x# ==# x# = True
<a name="line-42"></a>&quot;x# /=# x#&quot; forall x#. x# /=# x# = False
<a name="line-43"></a>&quot;x# &lt;# x#&quot;  forall x#. x# &lt;#  x# = False
<a name="line-44"></a>&quot;x# &lt;=# x#&quot; forall x#. x# &lt;=# x# = True
<a name="line-45"></a>  #-}</span>
<a name="line-46"></a>
<a name="line-47"></a><span class="hs-comment">{-# RULES
<a name="line-48"></a>&quot;plusFloat x 0.0&quot;   forall x#. plusFloat#  x#   0.0# = x#
<a name="line-49"></a>&quot;plusFloat 0.0 x&quot;   forall x#. plusFloat#  0.0# x#   = x#
<a name="line-50"></a>&quot;minusFloat x 0.0&quot;  forall x#. minusFloat# x#   0.0# = x#
<a name="line-51"></a>&quot;timesFloat x 1.0&quot;  forall x#. timesFloat# x#   1.0# = x#
<a name="line-52"></a>&quot;timesFloat 1.0 x&quot;  forall x#. timesFloat# 1.0# x#   = x#
<a name="line-53"></a>&quot;divideFloat x 1.0&quot; forall x#. divideFloat# x#  1.0# = x#
<a name="line-54"></a>  #-}</span>
<a name="line-55"></a>
<a name="line-56"></a><span class="hs-comment">{-# RULES
<a name="line-57"></a>&quot;plusDouble x 0.0&quot;   forall x#. (+##) x#    0.0## = x#
<a name="line-58"></a>&quot;plusDouble 0.0 x&quot;   forall x#. (+##) 0.0## x#    = x#
<a name="line-59"></a>&quot;minusDouble x 0.0&quot;  forall x#. (-##) x#    0.0## = x#
<a name="line-60"></a>&quot;timesDouble x 1.0&quot;  forall x#. (*##) x#    1.0## = x#
<a name="line-61"></a>&quot;timesDouble 1.0 x&quot;  forall x#. (*##) 1.0## x#    = x#
<a name="line-62"></a>&quot;divideDouble x 1.0&quot; forall x#. (/##) x#    1.0## = x#
<a name="line-63"></a>  #-}</span>
<a name="line-64"></a>
<a name="line-65"></a><span class="hs-comment">{-
<a name="line-66"></a>We'd like to have more rules, but for example:
<a name="line-67"></a>
<a name="line-68"></a>This gives wrong answer (0) for NaN - NaN (should be NaN):
<a name="line-69"></a>    &quot;minusDouble x x&quot;    forall x#. (-##) x#    x#    = 0.0##
<a name="line-70"></a>
<a name="line-71"></a>This gives wrong answer (0) for 0 * NaN (should be NaN):
<a name="line-72"></a>    &quot;timesDouble 0.0 x&quot;  forall x#. (*##) 0.0## x#    = 0.0##
<a name="line-73"></a>
<a name="line-74"></a>This gives wrong answer (0) for NaN * 0 (should be NaN):
<a name="line-75"></a>    &quot;timesDouble x 0.0&quot;  forall x#. (*##) x#    0.0## = 0.0##
<a name="line-76"></a>
<a name="line-77"></a>These are tested by num014.
<a name="line-78"></a>
<a name="line-79"></a>Similarly for Float (#5178):
<a name="line-80"></a>
<a name="line-81"></a>&quot;minusFloat x x&quot;    forall x#. minusFloat# x#   x#   = 0.0#
<a name="line-82"></a>&quot;timesFloat0.0 x&quot;   forall x#. timesFloat# 0.0# x#   = 0.0#
<a name="line-83"></a>&quot;timesFloat x 0.0&quot;  forall x#. timesFloat# x#   0.0# = 0.0#
<a name="line-84"></a>-}</span>
<a name="line-85"></a>
<a name="line-86"></a><span class="hs-comment">-- Wrappers for the shift operations.  The uncheckedShift# family are</span>
<a name="line-87"></a><span class="hs-comment">-- undefined when the amount being shifted by is greater than the size</span>
<a name="line-88"></a><span class="hs-comment">-- in bits of Int#, so these wrappers perform a check and return</span>
<a name="line-89"></a><span class="hs-comment">-- either zero or -1 appropriately.</span>
<a name="line-90"></a><span class="hs-comment">--</span>
<a name="line-91"></a><span class="hs-comment">-- Note that these wrappers still produce undefined results when the</span>
<a name="line-92"></a><span class="hs-comment">-- second argument (the shift amount) is negative.</span>
<a name="line-93"></a>
<a name="line-94"></a><a name="shiftL"></a><span class="hs-comment">-- | Shift the argument left by the specified number of bits</span>
<a name="line-95"></a><span class="hs-comment">-- (which must be non-negative).</span>
<a name="line-96"></a><span class="hs-definition">shiftL</span><span class="hs-cpp">#</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Word</span><span class="hs-cpp">#</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span><span class="hs-cpp">#</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Word</span><span class="hs-cpp">#</span>
<a name="line-97"></a><a name></a><span class="hs-definition">a</span> <span class="hs-varop">`</span><span class="hs-varid">shiftL</span><span class="hs-cpp">#</span><span class="hs-varop">`</span> <span class="hs-varid">b</span>   <span class="hs-keyglyph">|</span> <span class="hs-varid">b</span> <span class="hs-varop">&gt;=#</span> <span class="hs-conid">WORD_SIZE_IN_BITS</span><span class="hs-cpp">#</span> <span class="hs-keyglyph">=</span> <span class="hs-num">0</span><span class="hs-cpp">##</span>
<a name="line-98"></a>                <span class="hs-keyglyph">|</span> <span class="hs-varid">otherwise</span>                <span class="hs-keyglyph">=</span> <span class="hs-varid">a</span> <span class="hs-varop">`</span><span class="hs-varid">uncheckedShiftL</span><span class="hs-cpp">#</span><span class="hs-varop">`</span> <span class="hs-varid">b</span>
<a name="line-99"></a>
<a name="line-100"></a><a name="shiftRL"></a><span class="hs-comment">-- | Shift the argument right by the specified number of bits</span>
<a name="line-101"></a><span class="hs-comment">-- (which must be non-negative).</span>
<a name="line-102"></a><span class="hs-definition">shiftRL</span><span class="hs-cpp">#</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Word</span><span class="hs-cpp">#</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span><span class="hs-cpp">#</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Word</span><span class="hs-cpp">#</span>
<a name="line-103"></a><a name></a><span class="hs-definition">a</span> <span class="hs-varop">`</span><span class="hs-varid">shiftRL</span><span class="hs-cpp">#</span><span class="hs-varop">`</span> <span class="hs-varid">b</span>  <span class="hs-keyglyph">|</span> <span class="hs-varid">b</span> <span class="hs-varop">&gt;=#</span> <span class="hs-conid">WORD_SIZE_IN_BITS</span><span class="hs-cpp">#</span> <span class="hs-keyglyph">=</span> <span class="hs-num">0</span><span class="hs-cpp">##</span>
<a name="line-104"></a>                <span class="hs-keyglyph">|</span> <span class="hs-varid">otherwise</span>                <span class="hs-keyglyph">=</span> <span class="hs-varid">a</span> <span class="hs-varop">`</span><span class="hs-varid">uncheckedShiftRL</span><span class="hs-cpp">#</span><span class="hs-varop">`</span> <span class="hs-varid">b</span>
<a name="line-105"></a>
<a name="line-106"></a><a name="iShiftL"></a><span class="hs-comment">-- | Shift the argument left by the specified number of bits</span>
<a name="line-107"></a><span class="hs-comment">-- (which must be non-negative).</span>
<a name="line-108"></a><span class="hs-definition">iShiftL</span><span class="hs-cpp">#</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int</span><span class="hs-cpp">#</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span><span class="hs-cpp">#</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span><span class="hs-cpp">#</span>
<a name="line-109"></a><a name></a><span class="hs-definition">a</span> <span class="hs-varop">`</span><span class="hs-varid">iShiftL</span><span class="hs-cpp">#</span><span class="hs-varop">`</span> <span class="hs-varid">b</span>  <span class="hs-keyglyph">|</span> <span class="hs-varid">b</span> <span class="hs-varop">&gt;=#</span> <span class="hs-conid">WORD_SIZE_IN_BITS</span><span class="hs-cpp">#</span> <span class="hs-keyglyph">=</span> <span class="hs-num">0</span><span class="hs-cpp">#</span>
<a name="line-110"></a>                <span class="hs-keyglyph">|</span> <span class="hs-varid">otherwise</span>                <span class="hs-keyglyph">=</span> <span class="hs-varid">a</span> <span class="hs-varop">`</span><span class="hs-varid">uncheckedIShiftL</span><span class="hs-cpp">#</span><span class="hs-varop">`</span> <span class="hs-varid">b</span>
<a name="line-111"></a>
<a name="line-112"></a><a name="iShiftRA"></a><span class="hs-comment">-- | Shift the argument right (signed) by the specified number of bits</span>
<a name="line-113"></a><span class="hs-comment">-- (which must be non-negative).</span>
<a name="line-114"></a><span class="hs-definition">iShiftRA</span><span class="hs-cpp">#</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int</span><span class="hs-cpp">#</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span><span class="hs-cpp">#</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span><span class="hs-cpp">#</span>
<a name="line-115"></a><a name></a><span class="hs-definition">a</span> <span class="hs-varop">`</span><span class="hs-varid">iShiftRA</span><span class="hs-cpp">#</span><span class="hs-varop">`</span> <span class="hs-varid">b</span> <span class="hs-keyglyph">|</span> <span class="hs-varid">b</span> <span class="hs-varop">&gt;=#</span> <span class="hs-conid">WORD_SIZE_IN_BITS</span><span class="hs-cpp">#</span> <span class="hs-keyglyph">=</span> <span class="hs-keyword">if</span> <span class="hs-varid">a</span> <span class="hs-varop">&lt;#</span> <span class="hs-num">0</span><span class="hs-cpp">#</span> <span class="hs-keyword">then</span> <span class="hs-layout">(</span><span class="hs-comment">-</span><span class="hs-num">1</span><span class="hs-cpp">#</span><span class="hs-layout">)</span> <span class="hs-keyword">else</span> <span class="hs-num">0</span><span class="hs-cpp">#</span>
<a name="line-116"></a>                <span class="hs-keyglyph">|</span> <span class="hs-varid">otherwise</span>                <span class="hs-keyglyph">=</span> <span class="hs-varid">a</span> <span class="hs-varop">`</span><span class="hs-varid">uncheckedIShiftRA</span><span class="hs-cpp">#</span><span class="hs-varop">`</span> <span class="hs-varid">b</span>
<a name="line-117"></a>
<a name="line-118"></a><a name="iShiftRL"></a><span class="hs-comment">-- | Shift the argument right (unsigned) by the specified number of bits</span>
<a name="line-119"></a><span class="hs-comment">-- (which must be non-negative).</span>
<a name="line-120"></a><span class="hs-definition">iShiftRL</span><span class="hs-cpp">#</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int</span><span class="hs-cpp">#</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span><span class="hs-cpp">#</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span><span class="hs-cpp">#</span>
<a name="line-121"></a><a name></a><span class="hs-definition">a</span> <span class="hs-varop">`</span><span class="hs-varid">iShiftRL</span><span class="hs-cpp">#</span><span class="hs-varop">`</span> <span class="hs-varid">b</span> <span class="hs-keyglyph">|</span> <span class="hs-varid">b</span> <span class="hs-varop">&gt;=#</span> <span class="hs-conid">WORD_SIZE_IN_BITS</span><span class="hs-cpp">#</span> <span class="hs-keyglyph">=</span> <span class="hs-num">0</span><span class="hs-cpp">#</span>
<a name="line-122"></a>                <span class="hs-keyglyph">|</span> <span class="hs-varid">otherwise</span>                <span class="hs-keyglyph">=</span> <span class="hs-varid">a</span> <span class="hs-varop">`</span><span class="hs-varid">uncheckedIShiftRL</span><span class="hs-cpp">#</span><span class="hs-varop">`</span> <span class="hs-varid">b</span>
<a name="line-123"></a>
<a name="line-124"></a><span class="hs-cpp">#if WORD_SIZE_IN_BITS == 32</span>
<a name="line-125"></a><span class="hs-comment">{-# RULES
<a name="line-126"></a>&quot;narrow32Int#&quot;  forall x#. narrow32Int#   x# = x#
<a name="line-127"></a>&quot;narrow32Word#&quot; forall x#. narrow32Word#   x# = x#
<a name="line-128"></a>   #-}</span>
<a name="line-129"></a><span class="hs-cpp">#endif</span>
<a name="line-130"></a>
<a name="line-131"></a><span class="hs-comment">{-# RULES
<a name="line-132"></a>&quot;int2Word2Int&quot;  forall x#. int2Word# (word2Int# x#) = x#
<a name="line-133"></a>&quot;word2Int2Word&quot; forall x#. word2Int# (int2Word# x#) = x#
<a name="line-134"></a>  #-}</span>
<a name="line-135"></a>
<a name="line-136"></a>
<a name="line-137"></a><span class="hs-comment">-- Rules for C strings (the functions themselves are now in GHC.CString)</span>
<a name="line-138"></a><span class="hs-comment">{-# RULES
<a name="line-139"></a>&quot;unpack&quot;       [~1] forall a   . unpackCString# a             = build (unpackFoldrCString# a)
<a name="line-140"></a>&quot;unpack-list&quot;  [1]  forall a   . unpackFoldrCString# a (:) [] = unpackCString# a
<a name="line-141"></a>&quot;unpack-append&quot;     forall a n . unpackFoldrCString# a (:) n  = unpackAppendCString# a n
<a name="line-142"></a>
<a name="line-143"></a>-- There's a built-in rule (in PrelRules.lhs) for
<a name="line-144"></a>--      unpackFoldr &quot;foo&quot; c (unpackFoldr &quot;baz&quot; c n)  =  unpackFoldr &quot;foobaz&quot; c n
<a name="line-145"></a>
<a name="line-146"></a>  #-}</span>
</pre>\end{code}


#ifdef __HADDOCK__
\begin{code}
<pre><a name="line-1"></a><span class="hs-comment">-- | A special argument for the 'Control.Monad.ST.ST' type constructor,</span>
<a name="line-2"></a><span class="hs-comment">-- indexing a state embedded in the 'Prelude.IO' monad by</span>
<a name="line-3"></a><span class="hs-comment">-- 'Control.Monad.ST.stToIO'.</span>
<a name="line-4"></a><span class="hs-keyword">data</span> <span class="hs-conid">RealWorld</span>
</pre>\end{code}
#endif

</body>
</html>
