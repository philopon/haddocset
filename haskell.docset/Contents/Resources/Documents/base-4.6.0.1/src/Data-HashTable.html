<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>Data/HashTable.hs</title>
<link type="text/css" rel="stylesheet" href="hscolour.css"></link>
</head>
<body>
<pre><a name="line-1"></a><span class="hs-comment">{-# LANGUAGE Trustworthy #-}</span>
<a name="line-2"></a><span class="hs-comment">{-# LANGUAGE CPP, NoImplicitPrelude #-}</span>
<a name="line-3"></a><span class="hs-comment">{-# OPTIONS_GHC -funbox-strict-fields -fno-warn-name-shadowing #-}</span>
<a name="line-4"></a>
<a name="line-5"></a><span class="hs-comment">-----------------------------------------------------------------------------</span>
<a name="line-6"></a><span class="hs-comment">-- |</span>
<a name="line-7"></a><span class="hs-comment">-- Module      :  Data.HashTable</span>
<a name="line-8"></a><span class="hs-comment">-- Copyright   :  (c) The University of Glasgow 2003</span>
<a name="line-9"></a><span class="hs-comment">-- License     :  BSD-style (see the file libraries/base/LICENSE)</span>
<a name="line-10"></a><span class="hs-comment">--</span>
<a name="line-11"></a><span class="hs-comment">-- Maintainer  :  libraries@haskell.org</span>
<a name="line-12"></a><span class="hs-comment">-- Stability   :  provisional</span>
<a name="line-13"></a><span class="hs-comment">-- Portability :  portable</span>
<a name="line-14"></a><span class="hs-comment">--</span>
<a name="line-15"></a><span class="hs-comment">-- An implementation of extensible hash tables, as described in</span>
<a name="line-16"></a><span class="hs-comment">-- Per-Ake Larson, /Dynamic Hash Tables/, CACM 31(4), April 1988,</span>
<a name="line-17"></a><span class="hs-comment">-- pp. 446--457.  The implementation is also derived from the one</span>
<a name="line-18"></a><span class="hs-comment">-- in GHC's runtime system (@ghc\/rts\/Hash.{c,h}@).</span>
<a name="line-19"></a><span class="hs-comment">--</span>
<a name="line-20"></a><span class="hs-comment">-----------------------------------------------------------------------------</span>
<a name="line-21"></a>
<a name="line-22"></a><span class="hs-keyword">module</span> <span class="hs-conid">Data</span><span class="hs-varop">.</span><span class="hs-conid">HashTable</span>
<a name="line-23"></a>      <span class="hs-comment">{-# DEPRECATED &quot;Data.HashTable will be removed in GHC 7.8. Please use an alternative, e.g. the hashtables package, instead.&quot; #-}</span>
<a name="line-24"></a>      <span class="hs-layout">(</span>
<a name="line-25"></a>        <span class="hs-comment">-- * Basic hash table operations</span>
<a name="line-26"></a>        <span class="hs-conid">HashTable</span><span class="hs-layout">,</span> <span class="hs-varid">new</span><span class="hs-layout">,</span> <span class="hs-varid">newHint</span><span class="hs-layout">,</span> <span class="hs-varid">insert</span><span class="hs-layout">,</span> <span class="hs-varid">delete</span><span class="hs-layout">,</span> <span class="hs-varid">lookup</span><span class="hs-layout">,</span> <span class="hs-varid">update</span><span class="hs-layout">,</span>
<a name="line-27"></a>        <span class="hs-comment">-- * Converting to and from lists</span>
<a name="line-28"></a>        <span class="hs-varid">fromList</span><span class="hs-layout">,</span> <span class="hs-varid">toList</span><span class="hs-layout">,</span>
<a name="line-29"></a>        <span class="hs-comment">-- * Hash functions</span>
<a name="line-30"></a>        <span class="hs-comment">-- $hash_functions</span>
<a name="line-31"></a>        <span class="hs-varid">hashInt</span><span class="hs-layout">,</span> <span class="hs-varid">hashString</span><span class="hs-layout">,</span>
<a name="line-32"></a>        <span class="hs-varid">prime</span><span class="hs-layout">,</span>
<a name="line-33"></a>        <span class="hs-comment">-- * Diagnostics</span>
<a name="line-34"></a>        <span class="hs-varid">longestChain</span>
<a name="line-35"></a> <span class="hs-layout">)</span> <span class="hs-keyword">where</span>
<a name="line-36"></a>
<a name="line-37"></a><span class="hs-comment">-- This module is imported by Data.Dynamic, which is pretty low down in the</span>
<a name="line-38"></a><span class="hs-comment">-- module hierarchy, so don't import &quot;high-level&quot; modules</span>
<a name="line-39"></a>
<a name="line-40"></a><span class="hs-cpp">#ifdef __GLASGOW_HASKELL__</span>
<a name="line-41"></a><span class="hs-keyword">import</span> <span class="hs-conid">GHC</span><span class="hs-varop">.</span><span class="hs-conid">Base</span>
<a name="line-42"></a><span class="hs-cpp">#else</span>
<a name="line-43"></a><span class="hs-keyword">import</span> <span class="hs-conid">Prelude</span>  <span class="hs-varid">hiding</span>  <span class="hs-layout">(</span> <span class="hs-varid">lookup</span> <span class="hs-layout">)</span>
<a name="line-44"></a><span class="hs-cpp">#endif</span>
<a name="line-45"></a><span class="hs-keyword">import</span> <span class="hs-conid">Data</span><span class="hs-varop">.</span><span class="hs-conid">Tuple</span>       <span class="hs-layout">(</span> <span class="hs-varid">fst</span> <span class="hs-layout">)</span>
<a name="line-46"></a><span class="hs-keyword">import</span> <span class="hs-conid">Data</span><span class="hs-varop">.</span><span class="hs-conid">Bits</span>
<a name="line-47"></a><span class="hs-keyword">import</span> <span class="hs-conid">Data</span><span class="hs-varop">.</span><span class="hs-conid">Maybe</span>
<a name="line-48"></a><span class="hs-keyword">import</span> <span class="hs-conid">Data</span><span class="hs-varop">.</span><span class="hs-conid">List</span>        <span class="hs-layout">(</span> <span class="hs-varid">maximumBy</span><span class="hs-layout">,</span> <span class="hs-varid">length</span><span class="hs-layout">,</span> <span class="hs-varid">concat</span><span class="hs-layout">,</span> <span class="hs-varid">foldl'</span><span class="hs-layout">,</span> <span class="hs-varid">partition</span> <span class="hs-layout">)</span>
<a name="line-49"></a><span class="hs-keyword">import</span> <span class="hs-conid">Data</span><span class="hs-varop">.</span><span class="hs-conid">Int</span>         <span class="hs-layout">(</span> <span class="hs-conid">Int32</span> <span class="hs-layout">)</span>
<a name="line-50"></a>
<a name="line-51"></a><span class="hs-cpp">#if defined(__GLASGOW_HASKELL__)</span>
<a name="line-52"></a><span class="hs-keyword">import</span> <span class="hs-conid">GHC</span><span class="hs-varop">.</span><span class="hs-conid">Num</span>
<a name="line-53"></a><span class="hs-keyword">import</span> <span class="hs-conid">GHC</span><span class="hs-varop">.</span><span class="hs-conid">Real</span>         <span class="hs-layout">(</span> <span class="hs-varid">fromIntegral</span> <span class="hs-layout">)</span>
<a name="line-54"></a><span class="hs-keyword">import</span> <span class="hs-conid">GHC</span><span class="hs-varop">.</span><span class="hs-conid">Show</span>         <span class="hs-layout">(</span> <span class="hs-conid">Show</span><span class="hs-layout">(</span><span class="hs-keyglyph">..</span><span class="hs-layout">)</span> <span class="hs-layout">)</span>
<a name="line-55"></a><span class="hs-keyword">import</span> <span class="hs-conid">GHC</span><span class="hs-varop">.</span><span class="hs-conid">Int</span>          <span class="hs-layout">(</span> <span class="hs-conid">Int64</span> <span class="hs-layout">)</span>
<a name="line-56"></a>
<a name="line-57"></a><span class="hs-keyword">import</span> <span class="hs-conid">GHC</span><span class="hs-varop">.</span><span class="hs-conid">IO</span>
<a name="line-58"></a><span class="hs-keyword">import</span> <span class="hs-conid">GHC</span><span class="hs-varop">.</span><span class="hs-conid">IOArray</span>
<a name="line-59"></a><span class="hs-keyword">import</span> <span class="hs-conid">GHC</span><span class="hs-varop">.</span><span class="hs-conid">IORef</span>
<a name="line-60"></a><span class="hs-cpp">#else</span>
<a name="line-61"></a><span class="hs-keyword">import</span> <span class="hs-conid">Data</span><span class="hs-varop">.</span><span class="hs-conid">Char</span>        <span class="hs-layout">(</span> <span class="hs-varid">ord</span> <span class="hs-layout">)</span>
<a name="line-62"></a><span class="hs-keyword">import</span> <span class="hs-conid">Data</span><span class="hs-varop">.</span><span class="hs-conid">IORef</span>       <span class="hs-layout">(</span> <span class="hs-conid">IORef</span><span class="hs-layout">,</span> <span class="hs-varid">newIORef</span><span class="hs-layout">,</span> <span class="hs-varid">readIORef</span><span class="hs-layout">,</span> <span class="hs-varid">writeIORef</span> <span class="hs-layout">)</span>
<a name="line-63"></a><span class="hs-keyword">import</span> <span class="hs-conid">System</span><span class="hs-varop">.</span><span class="hs-conid">IO</span><span class="hs-varop">.</span><span class="hs-conid">Unsafe</span> <span class="hs-layout">(</span> <span class="hs-varid">unsafePerformIO</span> <span class="hs-layout">)</span>
<a name="line-64"></a><span class="hs-keyword">import</span> <span class="hs-conid">Data</span><span class="hs-varop">.</span><span class="hs-conid">Int</span>         <span class="hs-layout">(</span> <span class="hs-conid">Int64</span> <span class="hs-layout">)</span>
<a name="line-65"></a><span class="hs-cpp">#  if defined(__HUGS__)</span>
<a name="line-66"></a><span class="hs-keyword">import</span> <span class="hs-conid">Hugs</span><span class="hs-varop">.</span><span class="hs-conid">IOArray</span>     <span class="hs-layout">(</span> <span class="hs-conid">IOArray</span><span class="hs-layout">,</span> <span class="hs-varid">newIOArray</span><span class="hs-layout">,</span>
<a name="line-67"></a>                          <span class="hs-varid">unsafeReadIOArray</span><span class="hs-layout">,</span> <span class="hs-varid">unsafeWriteIOArray</span> <span class="hs-layout">)</span>
<a name="line-68"></a><span class="hs-cpp">#  elif defined(__NHC__)</span>
<a name="line-69"></a><span class="hs-keyword">import</span> <span class="hs-conid">NHC</span><span class="hs-varop">.</span><span class="hs-conid">IOExtras</span>     <span class="hs-layout">(</span> <span class="hs-conid">IOArray</span><span class="hs-layout">,</span> <span class="hs-varid">newIOArray</span><span class="hs-layout">,</span> <span class="hs-varid">readIOArray</span><span class="hs-layout">,</span> <span class="hs-varid">writeIOArray</span> <span class="hs-layout">)</span>
<a name="line-70"></a><span class="hs-cpp">#  endif</span>
<a name="line-71"></a><span class="hs-cpp">#endif</span>
<a name="line-72"></a><span class="hs-keyword">import</span> <span class="hs-conid">Control</span><span class="hs-varop">.</span><span class="hs-conid">Monad</span>    <span class="hs-layout">(</span> <span class="hs-varid">mapM</span><span class="hs-layout">,</span> <span class="hs-varid">mapM_</span><span class="hs-layout">,</span> <span class="hs-varid">sequence_</span> <span class="hs-layout">)</span>
<a name="line-73"></a>
<a name="line-74"></a>
<a name="line-75"></a><span class="hs-comment">-----------------------------------------------------------------------</span>
<a name="line-76"></a>
<a name="line-77"></a><a name="iNSTRUMENTED"></a><span class="hs-definition">iNSTRUMENTED</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Bool</span>
<a name="line-78"></a><span class="hs-definition">iNSTRUMENTED</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">False</span>
<a name="line-79"></a>
<a name="line-80"></a><span class="hs-comment">-----------------------------------------------------------------------</span>
<a name="line-81"></a>
<a name="line-82"></a><a name="readHTArray"></a><span class="hs-definition">readHTArray</span>  <span class="hs-keyglyph">::</span> <span class="hs-conid">HTArray</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int32</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">IO</span> <span class="hs-varid">a</span>
<a name="line-83"></a><a name="writeMutArray"></a><span class="hs-definition">writeMutArray</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">MutArray</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int32</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">IO</span> <span class="hs-conid">()</span>
<a name="line-84"></a><a name="newMutArray"></a><span class="hs-definition">newMutArray</span>   <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-conid">Int32</span><span class="hs-layout">,</span> <span class="hs-conid">Int32</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">IO</span> <span class="hs-layout">(</span><span class="hs-conid">MutArray</span> <span class="hs-varid">a</span><span class="hs-layout">)</span>
<a name="line-85"></a><span class="hs-definition">newMutArray</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">newIOArray</span>
<a name="line-86"></a><a name="MutArray"></a><span class="hs-keyword">type</span> <span class="hs-conid">MutArray</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">IOArray</span> <span class="hs-conid">Int32</span> <span class="hs-varid">a</span>
<a name="line-87"></a><a name="HTArray"></a><span class="hs-keyword">type</span> <span class="hs-conid">HTArray</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">MutArray</span> <span class="hs-varid">a</span>
<a name="line-88"></a><span class="hs-cpp">#if defined(DEBUG) || defined(__NHC__)</span>
<a name="line-89"></a><span class="hs-definition">readHTArray</span>  <span class="hs-keyglyph">=</span> <span class="hs-varid">readIOArray</span>
<a name="line-90"></a><span class="hs-definition">writeMutArray</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">writeIOArray</span>
<a name="line-91"></a><span class="hs-cpp">#else</span>
<a name="line-92"></a><span class="hs-definition">readHTArray</span> <span class="hs-varid">arr</span> <span class="hs-varid">i</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">unsafeReadIOArray</span> <span class="hs-varid">arr</span> <span class="hs-layout">(</span><span class="hs-varid">fromIntegral</span> <span class="hs-varid">i</span><span class="hs-layout">)</span>
<a name="line-93"></a><span class="hs-definition">writeMutArray</span> <span class="hs-varid">arr</span> <span class="hs-varid">i</span> <span class="hs-varid">x</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">unsafeWriteIOArray</span> <span class="hs-varid">arr</span> <span class="hs-layout">(</span><span class="hs-varid">fromIntegral</span> <span class="hs-varid">i</span><span class="hs-layout">)</span> <span class="hs-varid">x</span>
<a name="line-94"></a><span class="hs-cpp">#endif</span>
<a name="line-95"></a>
<a name="line-96"></a><a name="HashTable"></a><span class="hs-keyword">data</span> <span class="hs-conid">HashTable</span> <span class="hs-varid">key</span> <span class="hs-varid">val</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">HashTable</span> <span class="hs-layout">{</span>
<a name="line-97"></a>                                     <span class="hs-varid">cmp</span>     <span class="hs-keyglyph">::</span> <span class="hs-varop">!</span><span class="hs-layout">(</span><span class="hs-varid">key</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">key</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Bool</span><span class="hs-layout">)</span><span class="hs-layout">,</span>
<a name="line-98"></a>                                     <span class="hs-varid">hash_fn</span> <span class="hs-keyglyph">::</span> <span class="hs-varop">!</span><span class="hs-layout">(</span><span class="hs-varid">key</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int32</span><span class="hs-layout">)</span><span class="hs-layout">,</span>
<a name="line-99"></a>                                     <span class="hs-varid">tab</span>     <span class="hs-keyglyph">::</span> <span class="hs-varop">!</span><span class="hs-layout">(</span><span class="hs-conid">IORef</span> <span class="hs-layout">(</span><span class="hs-conid">HT</span> <span class="hs-varid">key</span> <span class="hs-varid">val</span><span class="hs-layout">)</span><span class="hs-layout">)</span>
<a name="line-100"></a>                                   <span class="hs-layout">}</span>
<a name="line-101"></a><span class="hs-comment">-- TODO: the IORef should really be an MVar.</span>
<a name="line-102"></a>
<a name="line-103"></a><a name="HT"></a><span class="hs-keyword">data</span> <span class="hs-conid">HT</span> <span class="hs-varid">key</span> <span class="hs-varid">val</span>
<a name="line-104"></a>  <span class="hs-keyglyph">=</span> <span class="hs-conid">HT</span> <span class="hs-layout">{</span>
<a name="line-105"></a>        <span class="hs-varid">kcount</span>  <span class="hs-keyglyph">::</span> <span class="hs-varop">!</span><span class="hs-conid">Int32</span><span class="hs-layout">,</span>              <span class="hs-comment">-- Total number of keys.</span>
<a name="line-106"></a>        <span class="hs-varid">bmask</span>   <span class="hs-keyglyph">::</span> <span class="hs-varop">!</span><span class="hs-conid">Int32</span><span class="hs-layout">,</span>
<a name="line-107"></a>        <span class="hs-varid">buckets</span> <span class="hs-keyglyph">::</span> <span class="hs-varop">!</span><span class="hs-layout">(</span><span class="hs-conid">HTArray</span> <span class="hs-keyglyph">[</span><span class="hs-layout">(</span><span class="hs-varid">key</span><span class="hs-layout">,</span><span class="hs-varid">val</span><span class="hs-layout">)</span><span class="hs-keyglyph">]</span><span class="hs-layout">)</span>
<a name="line-108"></a>       <span class="hs-layout">}</span>
<a name="line-109"></a>
<a name="line-110"></a><span class="hs-comment">-- ------------------------------------------------------------</span>
<a name="line-111"></a><span class="hs-comment">-- Instrumentation for performance tuning</span>
<a name="line-112"></a>
<a name="line-113"></a><span class="hs-comment">-- This ought to be roundly ignored after optimization when</span>
<a name="line-114"></a><span class="hs-comment">-- iNSTRUMENTED=False.</span>
<a name="line-115"></a>
<a name="line-116"></a><a name="modifyIORef"></a><span class="hs-comment">-- STRICT version of modifyIORef!</span>
<a name="line-117"></a><span class="hs-definition">modifyIORef</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">IORef</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">IO</span> <span class="hs-conid">()</span>
<a name="line-118"></a><span class="hs-definition">modifyIORef</span> <span class="hs-varid">r</span> <span class="hs-varid">f</span> <span class="hs-keyglyph">=</span> <span class="hs-keyword">do</span>
<a name="line-119"></a>  <span class="hs-varid">v</span> <span class="hs-keyglyph">&lt;-</span> <span class="hs-varid">readIORef</span> <span class="hs-varid">r</span>
<a name="line-120"></a>  <span class="hs-keyword">let</span> <span class="hs-varid">z</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">f</span> <span class="hs-varid">v</span> <span class="hs-keyword">in</span> <span class="hs-varid">z</span> <span class="hs-varop">`seq`</span> <span class="hs-varid">writeIORef</span> <span class="hs-varid">r</span> <span class="hs-varid">z</span>
<a name="line-121"></a>
<a name="line-122"></a><a name="HashData"></a><span class="hs-keyword">data</span> <span class="hs-conid">HashData</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">HD</span> <span class="hs-layout">{</span>
<a name="line-123"></a>  <span class="hs-varid">tables</span> <span class="hs-keyglyph">::</span> <span class="hs-varop">!</span><span class="hs-conid">Integer</span><span class="hs-layout">,</span>
<a name="line-124"></a>  <span class="hs-varid">insertions</span> <span class="hs-keyglyph">::</span> <span class="hs-varop">!</span><span class="hs-conid">Integer</span><span class="hs-layout">,</span>
<a name="line-125"></a>  <span class="hs-varid">lookups</span> <span class="hs-keyglyph">::</span> <span class="hs-varop">!</span><span class="hs-conid">Integer</span><span class="hs-layout">,</span>
<a name="line-126"></a>  <span class="hs-varid">totBuckets</span> <span class="hs-keyglyph">::</span> <span class="hs-varop">!</span><span class="hs-conid">Integer</span><span class="hs-layout">,</span>
<a name="line-127"></a>  <span class="hs-varid">maxEntries</span> <span class="hs-keyglyph">::</span> <span class="hs-varop">!</span><span class="hs-conid">Int32</span><span class="hs-layout">,</span>
<a name="line-128"></a>  <span class="hs-varid">maxChain</span> <span class="hs-keyglyph">::</span> <span class="hs-varop">!</span><span class="hs-conid">Int</span><span class="hs-layout">,</span>
<a name="line-129"></a>  <span class="hs-varid">maxBuckets</span> <span class="hs-keyglyph">::</span> <span class="hs-varop">!</span><span class="hs-conid">Int32</span>
<a name="line-130"></a><span class="hs-layout">}</span> <span class="hs-keyword">deriving</span> <span class="hs-layout">(</span><span class="hs-conid">Eq</span><span class="hs-layout">,</span> <span class="hs-conid">Show</span><span class="hs-layout">)</span>
<a name="line-131"></a>
<a name="line-132"></a><a name="hashData"></a><span class="hs-comment">{-# NOINLINE hashData #-}</span>
<a name="line-133"></a><span class="hs-definition">hashData</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">IORef</span> <span class="hs-conid">HashData</span>
<a name="line-134"></a><span class="hs-definition">hashData</span> <span class="hs-keyglyph">=</span>  <span class="hs-varid">unsafePerformIO</span> <span class="hs-layout">(</span><span class="hs-varid">newIORef</span> <span class="hs-layout">(</span><span class="hs-conid">HD</span> <span class="hs-layout">{</span> <span class="hs-varid">tables</span><span class="hs-keyglyph">=</span><span class="hs-num">0</span><span class="hs-layout">,</span> <span class="hs-varid">insertions</span><span class="hs-keyglyph">=</span><span class="hs-num">0</span><span class="hs-layout">,</span> <span class="hs-varid">lookups</span><span class="hs-keyglyph">=</span><span class="hs-num">0</span><span class="hs-layout">,</span>
<a name="line-135"></a>                                            <span class="hs-varid">totBuckets</span><span class="hs-keyglyph">=</span><span class="hs-num">0</span><span class="hs-layout">,</span> <span class="hs-varid">maxEntries</span><span class="hs-keyglyph">=</span><span class="hs-num">0</span><span class="hs-layout">,</span>
<a name="line-136"></a>                                            <span class="hs-varid">maxChain</span><span class="hs-keyglyph">=</span><span class="hs-num">0</span><span class="hs-layout">,</span> <span class="hs-varid">maxBuckets</span><span class="hs-keyglyph">=</span><span class="hs-varid">tABLE_MIN</span> <span class="hs-layout">}</span> <span class="hs-layout">)</span><span class="hs-layout">)</span>
<a name="line-137"></a>
<a name="line-138"></a><a name="instrument"></a><span class="hs-definition">instrument</span> <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-conid">HashData</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">HashData</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">IO</span> <span class="hs-conid">()</span>
<a name="line-139"></a><span class="hs-definition">instrument</span> <span class="hs-varid">i</span> <span class="hs-keyglyph">|</span> <span class="hs-varid">iNSTRUMENTED</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">modifyIORef</span> <span class="hs-varid">hashData</span> <span class="hs-varid">i</span>
<a name="line-140"></a>             <span class="hs-keyglyph">|</span> <span class="hs-varid">otherwise</span>    <span class="hs-keyglyph">=</span> <span class="hs-varid">return</span> <span class="hs-conid">()</span>
<a name="line-141"></a>
<a name="line-142"></a><a name="recordNew"></a><span class="hs-definition">recordNew</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">IO</span> <span class="hs-conid">()</span>
<a name="line-143"></a><span class="hs-definition">recordNew</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">instrument</span> <span class="hs-varid">rec</span>
<a name="line-144"></a>  <span class="hs-keyword">where</span> <span class="hs-varid">rec</span> <span class="hs-varid">hd</span><span class="hs-keyglyph">@</span><span class="hs-conid">HD</span><span class="hs-layout">{</span> <span class="hs-varid">tables</span><span class="hs-keyglyph">=</span><span class="hs-varid">t</span><span class="hs-layout">,</span> <span class="hs-varid">totBuckets</span><span class="hs-keyglyph">=</span><span class="hs-varid">b</span> <span class="hs-layout">}</span> <span class="hs-keyglyph">=</span>
<a name="line-145"></a>               <span class="hs-varid">hd</span><span class="hs-layout">{</span> <span class="hs-varid">tables</span><span class="hs-keyglyph">=</span><span class="hs-varid">t</span><span class="hs-varop">+</span><span class="hs-num">1</span><span class="hs-layout">,</span> <span class="hs-varid">totBuckets</span><span class="hs-keyglyph">=</span><span class="hs-varid">b</span><span class="hs-varop">+</span><span class="hs-varid">fromIntegral</span> <span class="hs-varid">tABLE_MIN</span> <span class="hs-layout">}</span>
<a name="line-146"></a>
<a name="line-147"></a><a name="recordIns"></a><span class="hs-definition">recordIns</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int32</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int32</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">IO</span> <span class="hs-conid">()</span>
<a name="line-148"></a><span class="hs-definition">recordIns</span> <span class="hs-varid">i</span> <span class="hs-varid">sz</span> <span class="hs-varid">bkt</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">instrument</span> <span class="hs-varid">rec</span>
<a name="line-149"></a>  <span class="hs-keyword">where</span> <span class="hs-varid">rec</span> <span class="hs-varid">hd</span><span class="hs-keyglyph">@</span><span class="hs-conid">HD</span><span class="hs-layout">{</span> <span class="hs-varid">insertions</span><span class="hs-keyglyph">=</span><span class="hs-varid">ins</span><span class="hs-layout">,</span> <span class="hs-varid">maxEntries</span><span class="hs-keyglyph">=</span><span class="hs-varid">mx</span><span class="hs-layout">,</span> <span class="hs-varid">maxChain</span><span class="hs-keyglyph">=</span><span class="hs-varid">mc</span> <span class="hs-layout">}</span> <span class="hs-keyglyph">=</span>
<a name="line-150"></a>               <span class="hs-varid">hd</span><span class="hs-layout">{</span> <span class="hs-varid">insertions</span><span class="hs-keyglyph">=</span><span class="hs-varid">ins</span><span class="hs-varop">+</span><span class="hs-varid">fromIntegral</span> <span class="hs-varid">i</span><span class="hs-layout">,</span> <span class="hs-varid">maxEntries</span><span class="hs-keyglyph">=</span><span class="hs-varid">mx</span> <span class="hs-varop">`max`</span> <span class="hs-varid">sz</span><span class="hs-layout">,</span>
<a name="line-151"></a>                   <span class="hs-varid">maxChain</span><span class="hs-keyglyph">=</span><span class="hs-varid">mc</span> <span class="hs-varop">`max`</span> <span class="hs-varid">length</span> <span class="hs-varid">bkt</span> <span class="hs-layout">}</span>
<a name="line-152"></a>
<a name="line-153"></a><a name="recordResize"></a><span class="hs-definition">recordResize</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int32</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int32</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">IO</span> <span class="hs-conid">()</span>
<a name="line-154"></a><span class="hs-definition">recordResize</span> <span class="hs-varid">older</span> <span class="hs-varid">newer</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">instrument</span> <span class="hs-varid">rec</span>
<a name="line-155"></a>  <span class="hs-keyword">where</span> <span class="hs-varid">rec</span> <span class="hs-varid">hd</span><span class="hs-keyglyph">@</span><span class="hs-conid">HD</span><span class="hs-layout">{</span> <span class="hs-varid">totBuckets</span><span class="hs-keyglyph">=</span><span class="hs-varid">b</span><span class="hs-layout">,</span> <span class="hs-varid">maxBuckets</span><span class="hs-keyglyph">=</span><span class="hs-varid">mx</span> <span class="hs-layout">}</span> <span class="hs-keyglyph">=</span>
<a name="line-156"></a>               <span class="hs-varid">hd</span><span class="hs-layout">{</span> <span class="hs-varid">totBuckets</span><span class="hs-keyglyph">=</span><span class="hs-varid">b</span><span class="hs-varop">+</span><span class="hs-varid">fromIntegral</span> <span class="hs-layout">(</span><span class="hs-varid">newer</span><span class="hs-comment">-</span><span class="hs-varid">older</span><span class="hs-layout">)</span><span class="hs-layout">,</span>
<a name="line-157"></a>                   <span class="hs-varid">maxBuckets</span><span class="hs-keyglyph">=</span><span class="hs-varid">mx</span> <span class="hs-varop">`max`</span> <span class="hs-varid">newer</span> <span class="hs-layout">}</span>
<a name="line-158"></a>
<a name="line-159"></a><a name="recordLookup"></a><span class="hs-definition">recordLookup</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">IO</span> <span class="hs-conid">()</span>
<a name="line-160"></a><span class="hs-definition">recordLookup</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">instrument</span> <span class="hs-varid">lkup</span>
<a name="line-161"></a>  <span class="hs-keyword">where</span> <span class="hs-varid">lkup</span> <span class="hs-varid">hd</span><span class="hs-keyglyph">@</span><span class="hs-conid">HD</span><span class="hs-layout">{</span> <span class="hs-varid">lookups</span><span class="hs-keyglyph">=</span><span class="hs-varid">l</span> <span class="hs-layout">}</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">hd</span><span class="hs-layout">{</span> <span class="hs-varid">lookups</span><span class="hs-keyglyph">=</span><span class="hs-varid">l</span><span class="hs-varop">+</span><span class="hs-num">1</span> <span class="hs-layout">}</span>
<a name="line-162"></a>
<a name="line-163"></a><span class="hs-comment">-- stats :: IO String</span>
<a name="line-164"></a><span class="hs-comment">-- stats =  fmap show $ readIORef hashData</span>
<a name="line-165"></a>
<a name="line-166"></a><span class="hs-comment">-- ----------------------------------------------------------------------------</span>
<a name="line-167"></a><span class="hs-comment">-- Sample hash functions</span>
<a name="line-168"></a>
<a name="line-169"></a><span class="hs-comment">-- $hash_functions</span>
<a name="line-170"></a><span class="hs-comment">--</span>
<a name="line-171"></a><span class="hs-comment">-- This implementation of hash tables uses the low-order /n/ bits of the hash</span>
<a name="line-172"></a><span class="hs-comment">-- value for a key, where /n/ varies as the hash table grows.  A good hash</span>
<a name="line-173"></a><span class="hs-comment">-- function therefore will give an even distribution regardless of /n/.</span>
<a name="line-174"></a><span class="hs-comment">--</span>
<a name="line-175"></a><span class="hs-comment">-- If your keyspace is integrals such that the low-order bits between</span>
<a name="line-176"></a><span class="hs-comment">-- keys are highly variable, then you could get away with using 'fromIntegral'</span>
<a name="line-177"></a><span class="hs-comment">-- as the hash function.</span>
<a name="line-178"></a><span class="hs-comment">--</span>
<a name="line-179"></a><span class="hs-comment">-- We provide some sample hash functions for 'Int' and 'String' below.</span>
<a name="line-180"></a>
<a name="line-181"></a><a name="golden"></a><span class="hs-definition">golden</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int32</span>
<a name="line-182"></a><span class="hs-definition">golden</span> <span class="hs-keyglyph">=</span> <span class="hs-num">1013904242</span> <span class="hs-comment">-- = round ((sqrt 5 - 1) * 2^32) :: Int32</span>
<a name="line-183"></a><span class="hs-comment">-- was -1640531527 = round ((sqrt 5 - 1) * 2^31) :: Int32</span>
<a name="line-184"></a><span class="hs-comment">-- but that has bad mulHi properties (even adding 2^32 to get its inverse)</span>
<a name="line-185"></a><span class="hs-comment">-- Whereas the above works well and contains no hash duplications for</span>
<a name="line-186"></a><span class="hs-comment">-- [-32767..65536]</span>
<a name="line-187"></a>
<a name="line-188"></a><a name="hashInt32"></a><span class="hs-definition">hashInt32</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int32</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int32</span>
<a name="line-189"></a><span class="hs-definition">hashInt32</span> <span class="hs-varid">x</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">mulHi</span> <span class="hs-varid">x</span> <span class="hs-varid">golden</span> <span class="hs-varop">+</span> <span class="hs-varid">x</span>
<a name="line-190"></a>
<a name="line-191"></a><a name="hashInt"></a><span class="hs-comment">-- | A sample (and useful) hash function for Int and Int32,</span>
<a name="line-192"></a><span class="hs-comment">-- implemented by extracting the uppermost 32 bits of the 64-bit</span>
<a name="line-193"></a><span class="hs-comment">-- result of multiplying by a 33-bit constant.  The constant is from</span>
<a name="line-194"></a><span class="hs-comment">-- Knuth, derived from the golden ratio:</span>
<a name="line-195"></a><span class="hs-comment">--</span>
<a name="line-196"></a><span class="hs-comment">-- &gt; golden = round ((sqrt 5 - 1) * 2^32)</span>
<a name="line-197"></a><span class="hs-comment">--</span>
<a name="line-198"></a><span class="hs-comment">-- We get good key uniqueness on small inputs</span>
<a name="line-199"></a><span class="hs-comment">-- (a problem with previous versions):</span>
<a name="line-200"></a><span class="hs-comment">--  (length $ group $ sort $ map hashInt [-32767..65536]) == 65536 + 32768</span>
<a name="line-201"></a><span class="hs-comment">--</span>
<a name="line-202"></a><span class="hs-definition">hashInt</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int32</span>
<a name="line-203"></a><span class="hs-definition">hashInt</span> <span class="hs-varid">x</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">hashInt32</span> <span class="hs-layout">(</span><span class="hs-varid">fromIntegral</span> <span class="hs-varid">x</span><span class="hs-layout">)</span>
<a name="line-204"></a>
<a name="line-205"></a><a name="mulHi"></a><span class="hs-comment">-- hi 32 bits of a x-bit * 32 bit -&gt; 64-bit multiply</span>
<a name="line-206"></a><span class="hs-definition">mulHi</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int32</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int32</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int32</span>
<a name="line-207"></a><span class="hs-definition">mulHi</span> <span class="hs-varid">a</span> <span class="hs-varid">b</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">fromIntegral</span> <span class="hs-layout">(</span><span class="hs-varid">r</span> <span class="hs-varop">`shiftR`</span> <span class="hs-num">32</span><span class="hs-layout">)</span>
<a name="line-208"></a>   <span class="hs-keyword">where</span> <span class="hs-varid">r</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int64</span>
<a name="line-209"></a>         <span class="hs-varid">r</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">fromIntegral</span> <span class="hs-varid">a</span> <span class="hs-varop">*</span> <span class="hs-varid">fromIntegral</span> <span class="hs-varid">b</span>
<a name="line-210"></a>
<a name="line-211"></a><span class="hs-comment">-- | A sample hash function for Strings.  We keep multiplying by the</span>
<a name="line-212"></a><span class="hs-comment">-- golden ratio and adding.  The implementation is:</span>
<a name="line-213"></a><span class="hs-comment">--</span>
<a name="line-214"></a><span class="hs-comment">-- &gt; hashString = foldl' f golden</span>
<a name="line-215"></a><span class="hs-comment">-- &gt;   where f m c = fromIntegral (ord c) * magic + hashInt32 m</span>
<a name="line-216"></a><span class="hs-comment">-- &gt;         magic = 0xdeadbeef</span>
<a name="line-217"></a><span class="hs-comment">--</span>
<a name="line-218"></a><span class="hs-comment">-- Where hashInt32 works just as hashInt shown above.</span>
<a name="line-219"></a><span class="hs-comment">--</span>
<a name="line-220"></a><span class="hs-comment">-- Knuth argues that repeated multiplication by the golden ratio</span>
<a name="line-221"></a><span class="hs-comment">-- will minimize gaps in the hash space, and thus it's a good choice</span>
<a name="line-222"></a><span class="hs-comment">-- for combining together multiple keys to form one.</span>
<a name="line-223"></a><span class="hs-comment">--</span>
<a name="line-224"></a><span class="hs-comment">-- Here we know that individual characters c are often small, and this</span>
<a name="line-225"></a><span class="hs-comment">-- produces frequent collisions if we use ord c alone.  A</span>
<a name="line-226"></a><span class="hs-comment">-- particular problem are the shorter low ASCII and ISO-8859-1</span>
<a name="line-227"></a><span class="hs-comment">-- character strings.  We pre-multiply by a magic twiddle factor to</span>
<a name="line-228"></a><span class="hs-comment">-- obtain a good distribution.  In fact, given the following test:</span>
<a name="line-229"></a><span class="hs-comment">--</span>
<a name="line-230"></a><span class="hs-comment">-- &gt; testp :: Int32 -&gt; Int</span>
<a name="line-231"></a><span class="hs-comment">-- &gt; testp k = (n - ) . length . group . sort . map hs . take n $ ls</span>
<a name="line-232"></a><span class="hs-comment">-- &gt;   where ls = [] : [c : l | l &lt;- ls, c &lt;- ['\0'..'\xff']]</span>
<a name="line-233"></a><span class="hs-comment">-- &gt;         hs = foldl' f golden</span>
<a name="line-234"></a><span class="hs-comment">-- &gt;         f m c = fromIntegral (ord c) * k + hashInt32 m</span>
<a name="line-235"></a><span class="hs-comment">-- &gt;         n = 100000</span>
<a name="line-236"></a><span class="hs-comment">--</span>
<a name="line-237"></a><span class="hs-comment">-- We discover that testp magic = 0.</span>
<a name="line-238"></a>
<a name="line-239"></a><a name="hashString"></a><span class="hs-definition">hashString</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">String</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int32</span>
<a name="line-240"></a><span class="hs-definition">hashString</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">foldl'</span> <span class="hs-varid">f</span> <span class="hs-varid">golden</span>
<a name="line-241"></a>   <span class="hs-keyword">where</span> <span class="hs-varid">f</span> <span class="hs-varid">m</span> <span class="hs-varid">c</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">fromIntegral</span> <span class="hs-layout">(</span><span class="hs-varid">ord</span> <span class="hs-varid">c</span><span class="hs-layout">)</span> <span class="hs-varop">*</span> <span class="hs-varid">magic</span> <span class="hs-varop">+</span> <span class="hs-varid">hashInt32</span> <span class="hs-varid">m</span>
<a name="line-242"></a>         <span class="hs-varid">magic</span> <span class="hs-keyglyph">=</span> <span class="hs-num">0xdeadbeef</span>
<a name="line-243"></a>
<a name="line-244"></a><a name="prime"></a><span class="hs-comment">-- | A prime larger than the maximum hash table size</span>
<a name="line-245"></a><span class="hs-definition">prime</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int32</span>
<a name="line-246"></a><span class="hs-definition">prime</span> <span class="hs-keyglyph">=</span> <span class="hs-num">33554467</span>
<a name="line-247"></a>
<a name="line-248"></a><span class="hs-comment">-- -----------------------------------------------------------------------------</span>
<a name="line-249"></a><span class="hs-comment">-- Parameters</span>
<a name="line-250"></a>
<a name="line-251"></a><a name="tABLE_MAX"></a><span class="hs-definition">tABLE_MAX</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int32</span>
<a name="line-252"></a><span class="hs-definition">tABLE_MAX</span>  <span class="hs-keyglyph">=</span> <span class="hs-num">32</span> <span class="hs-varop">*</span> <span class="hs-num">1024</span> <span class="hs-varop">*</span> <span class="hs-num">1024</span>   <span class="hs-comment">-- Maximum size of hash table</span>
<a name="line-253"></a><a name="tABLE_MIN"></a><span class="hs-definition">tABLE_MIN</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int32</span>
<a name="line-254"></a><span class="hs-definition">tABLE_MIN</span>  <span class="hs-keyglyph">=</span> <span class="hs-num">8</span>
<a name="line-255"></a>
<a name="line-256"></a><a name="hLOAD"></a><span class="hs-definition">hLOAD</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int32</span>
<a name="line-257"></a><span class="hs-definition">hLOAD</span> <span class="hs-keyglyph">=</span> <span class="hs-num">7</span>                       <span class="hs-comment">-- Maximum average load of a single hash bucket</span>
<a name="line-258"></a>
<a name="line-259"></a><a name="hYSTERESIS"></a><span class="hs-definition">hYSTERESIS</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int32</span>
<a name="line-260"></a><span class="hs-definition">hYSTERESIS</span> <span class="hs-keyglyph">=</span> <span class="hs-num">64</span>                 <span class="hs-comment">-- entries to ignore in load computation</span>
<a name="line-261"></a>
<a name="line-262"></a><span class="hs-comment">{- Hysteresis favors long association-list-like behavior for small tables. -}</span>
<a name="line-263"></a>
<a name="line-264"></a><span class="hs-comment">-- -----------------------------------------------------------------------------</span>
<a name="line-265"></a><span class="hs-comment">-- Creating a new hash table</span>
<a name="line-266"></a>
<a name="line-267"></a><a name="new"></a><span class="hs-comment">-- | Creates a new hash table.  The following property should hold for the @eq@</span>
<a name="line-268"></a><span class="hs-comment">-- and @hash@ functions passed to 'new':</span>
<a name="line-269"></a><span class="hs-comment">--</span>
<a name="line-270"></a><span class="hs-comment">-- &gt;   eq A B  =&gt;  hash A == hash B</span>
<a name="line-271"></a><span class="hs-comment">--</span>
<a name="line-272"></a><span class="hs-definition">new</span>
<a name="line-273"></a>  <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-varid">key</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">key</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Bool</span><span class="hs-layout">)</span>    <span class="hs-comment">-- ^ @eq@: An equality comparison on keys</span>
<a name="line-274"></a>  <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-varid">key</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int32</span><span class="hs-layout">)</span>          <span class="hs-comment">-- ^ @hash@: A hash function on keys</span>
<a name="line-275"></a>  <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">IO</span> <span class="hs-layout">(</span><span class="hs-conid">HashTable</span> <span class="hs-varid">key</span> <span class="hs-varid">val</span><span class="hs-layout">)</span>  <span class="hs-comment">-- ^ Returns: an empty hash table</span>
<a name="line-276"></a>
<a name="line-277"></a><span class="hs-definition">new</span> <span class="hs-varid">cmpr</span> <span class="hs-varid">hash</span> <span class="hs-keyglyph">=</span> <span class="hs-keyword">do</span>
<a name="line-278"></a>  <span class="hs-varid">recordNew</span>
<a name="line-279"></a>  <span class="hs-comment">-- make a new hash table with a single, empty, segment</span>
<a name="line-280"></a>  <span class="hs-keyword">let</span> <span class="hs-varid">mask</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">tABLE_MIN</span><span class="hs-comment">-</span><span class="hs-num">1</span>
<a name="line-281"></a>  <span class="hs-varid">bkts</span> <span class="hs-keyglyph">&lt;-</span> <span class="hs-varid">newMutArray</span> <span class="hs-layout">(</span><span class="hs-num">0</span><span class="hs-layout">,</span><span class="hs-varid">mask</span><span class="hs-layout">)</span> <span class="hs-conid">[]</span>
<a name="line-282"></a>
<a name="line-283"></a>  <span class="hs-keyword">let</span>
<a name="line-284"></a>    <span class="hs-varid">kcnt</span> <span class="hs-keyglyph">=</span> <span class="hs-num">0</span>
<a name="line-285"></a>    <span class="hs-varid">ht</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">HT</span> <span class="hs-layout">{</span>  <span class="hs-varid">buckets</span><span class="hs-keyglyph">=</span><span class="hs-varid">bkts</span><span class="hs-layout">,</span> <span class="hs-varid">kcount</span><span class="hs-keyglyph">=</span><span class="hs-varid">kcnt</span><span class="hs-layout">,</span> <span class="hs-varid">bmask</span><span class="hs-keyglyph">=</span><span class="hs-varid">mask</span> <span class="hs-layout">}</span>
<a name="line-286"></a>
<a name="line-287"></a>  <span class="hs-varid">table</span> <span class="hs-keyglyph">&lt;-</span> <span class="hs-varid">newIORef</span> <span class="hs-varid">ht</span>
<a name="line-288"></a>  <span class="hs-varid">return</span> <span class="hs-layout">(</span><span class="hs-conid">HashTable</span> <span class="hs-layout">{</span> <span class="hs-varid">tab</span><span class="hs-keyglyph">=</span><span class="hs-varid">table</span><span class="hs-layout">,</span> <span class="hs-varid">hash_fn</span><span class="hs-keyglyph">=</span><span class="hs-varid">hash</span><span class="hs-layout">,</span> <span class="hs-varid">cmp</span><span class="hs-keyglyph">=</span><span class="hs-varid">cmpr</span> <span class="hs-layout">}</span><span class="hs-layout">)</span>
<a name="line-289"></a>
<a name="line-290"></a><a name="bitTwiddleSameAs"></a><span class="hs-comment">{- 
<a name="line-291"></a>   bitTwiddleSameAs takes as arguments positive Int32s less than maxBound/2 and 
<a name="line-292"></a>   returns the smallest power of 2 that is greater than or equal to the 
<a name="line-293"></a>   argument.
<a name="line-294"></a>   <a href="http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2">http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2</a>
<a name="line-295"></a>-}</span>
<a name="line-296"></a><span class="hs-definition">bitTwiddleSameAs</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int32</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int32</span>
<a name="line-297"></a><span class="hs-definition">bitTwiddleSameAs</span> <span class="hs-varid">v0</span> <span class="hs-keyglyph">=</span> 
<a name="line-298"></a>    <span class="hs-keyword">let</span> <span class="hs-varid">v1</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">v0</span><span class="hs-comment">-</span><span class="hs-num">1</span>
<a name="line-299"></a>        <span class="hs-varid">v2</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">v1</span> <span class="hs-varop">.|.</span> <span class="hs-layout">(</span><span class="hs-varid">v1</span><span class="hs-varop">`shiftR`</span><span class="hs-num">1</span><span class="hs-layout">)</span>
<a name="line-300"></a>        <span class="hs-varid">v3</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">v2</span> <span class="hs-varop">.|.</span> <span class="hs-layout">(</span><span class="hs-varid">v2</span><span class="hs-varop">`shiftR`</span><span class="hs-num">2</span><span class="hs-layout">)</span>
<a name="line-301"></a>        <span class="hs-varid">v4</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">v3</span> <span class="hs-varop">.|.</span> <span class="hs-layout">(</span><span class="hs-varid">v3</span><span class="hs-varop">`shiftR`</span><span class="hs-num">4</span><span class="hs-layout">)</span>
<a name="line-302"></a>        <span class="hs-varid">v5</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">v4</span> <span class="hs-varop">.|.</span> <span class="hs-layout">(</span><span class="hs-varid">v4</span><span class="hs-varop">`shiftR`</span><span class="hs-num">8</span><span class="hs-layout">)</span>
<a name="line-303"></a>        <span class="hs-varid">v6</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">v5</span> <span class="hs-varop">.|.</span> <span class="hs-layout">(</span><span class="hs-varid">v5</span><span class="hs-varop">`shiftR`</span><span class="hs-num">16</span><span class="hs-layout">)</span>
<a name="line-304"></a>    <span class="hs-keyword">in</span> <span class="hs-varid">v6</span><span class="hs-varop">+</span><span class="hs-num">1</span>
<a name="line-305"></a>
<a name="line-306"></a><a name="powerOver"></a><span class="hs-comment">{-
<a name="line-307"></a>  powerOver takes as arguments Int32s and returns the smallest power of 2 
<a name="line-308"></a>  that is greater than or equal to the argument if that power of 2 is 
<a name="line-309"></a>  within [tABLE_MIN,tABLE_MAX]
<a name="line-310"></a>-}</span>
<a name="line-311"></a><span class="hs-definition">powerOver</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int32</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int32</span>
<a name="line-312"></a><span class="hs-definition">powerOver</span> <span class="hs-varid">n</span> <span class="hs-keyglyph">=</span> 
<a name="line-313"></a>    <span class="hs-keyword">if</span> <span class="hs-varid">n</span> <span class="hs-varop">&lt;=</span> <span class="hs-varid">tABLE_MIN</span>
<a name="line-314"></a>    <span class="hs-keyword">then</span> <span class="hs-varid">tABLE_MIN</span>
<a name="line-315"></a>    <span class="hs-keyword">else</span> <span class="hs-keyword">if</span> <span class="hs-varid">n</span> <span class="hs-varop">&gt;=</span> <span class="hs-varid">tABLE_MAX</span>
<a name="line-316"></a>         <span class="hs-keyword">then</span> <span class="hs-varid">tABLE_MAX</span>
<a name="line-317"></a>         <span class="hs-keyword">else</span> <span class="hs-varid">bitTwiddleSameAs</span> <span class="hs-varid">n</span> 
<a name="line-318"></a>
<a name="line-319"></a><a name="newHint"></a><span class="hs-comment">-- | Creates a new hash table with the given minimum size.</span>
<a name="line-320"></a><span class="hs-definition">newHint</span>
<a name="line-321"></a>  <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-varid">key</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">key</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Bool</span><span class="hs-layout">)</span>    <span class="hs-comment">-- ^ @eq@: An equality comparison on keys</span>
<a name="line-322"></a>  <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-varid">key</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int32</span><span class="hs-layout">)</span>          <span class="hs-comment">-- ^ @hash@: A hash function on keys</span>
<a name="line-323"></a>  <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span>                     <span class="hs-comment">-- ^ @minSize@: initial table size</span>
<a name="line-324"></a>  <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">IO</span> <span class="hs-layout">(</span><span class="hs-conid">HashTable</span> <span class="hs-varid">key</span> <span class="hs-varid">val</span><span class="hs-layout">)</span>  <span class="hs-comment">-- ^ Returns: an empty hash table</span>
<a name="line-325"></a>
<a name="line-326"></a><span class="hs-definition">newHint</span> <span class="hs-varid">cmpr</span> <span class="hs-varid">hash</span> <span class="hs-varid">minSize</span> <span class="hs-keyglyph">=</span> <span class="hs-keyword">do</span>
<a name="line-327"></a>  <span class="hs-varid">recordNew</span>
<a name="line-328"></a>  <span class="hs-comment">-- make a new hash table with a single, empty, segment</span>
<a name="line-329"></a>  <span class="hs-keyword">let</span> <span class="hs-varid">mask</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">powerOver</span> <span class="hs-varop">$</span> <span class="hs-varid">fromIntegral</span> <span class="hs-varid">minSize</span>
<a name="line-330"></a>  <span class="hs-varid">bkts</span> <span class="hs-keyglyph">&lt;-</span> <span class="hs-varid">newMutArray</span> <span class="hs-layout">(</span><span class="hs-num">0</span><span class="hs-layout">,</span><span class="hs-varid">mask</span><span class="hs-layout">)</span> <span class="hs-conid">[]</span>
<a name="line-331"></a>
<a name="line-332"></a>  <span class="hs-keyword">let</span>
<a name="line-333"></a>    <span class="hs-varid">kcnt</span> <span class="hs-keyglyph">=</span> <span class="hs-num">0</span>
<a name="line-334"></a>    <span class="hs-varid">ht</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">HT</span> <span class="hs-layout">{</span>  <span class="hs-varid">buckets</span><span class="hs-keyglyph">=</span><span class="hs-varid">bkts</span><span class="hs-layout">,</span> <span class="hs-varid">kcount</span><span class="hs-keyglyph">=</span><span class="hs-varid">kcnt</span><span class="hs-layout">,</span> <span class="hs-varid">bmask</span><span class="hs-keyglyph">=</span><span class="hs-varid">mask</span> <span class="hs-layout">}</span>
<a name="line-335"></a>
<a name="line-336"></a>  <span class="hs-varid">table</span> <span class="hs-keyglyph">&lt;-</span> <span class="hs-varid">newIORef</span> <span class="hs-varid">ht</span>
<a name="line-337"></a>  <span class="hs-varid">return</span> <span class="hs-layout">(</span><span class="hs-conid">HashTable</span> <span class="hs-layout">{</span> <span class="hs-varid">tab</span><span class="hs-keyglyph">=</span><span class="hs-varid">table</span><span class="hs-layout">,</span> <span class="hs-varid">hash_fn</span><span class="hs-keyglyph">=</span><span class="hs-varid">hash</span><span class="hs-layout">,</span> <span class="hs-varid">cmp</span><span class="hs-keyglyph">=</span><span class="hs-varid">cmpr</span> <span class="hs-layout">}</span><span class="hs-layout">)</span>
<a name="line-338"></a>
<a name="line-339"></a><span class="hs-comment">-- -----------------------------------------------------------------------------</span>
<a name="line-340"></a><span class="hs-comment">-- Inserting a key\/value pair into the hash table</span>
<a name="line-341"></a>
<a name="line-342"></a><a name="insert"></a><span class="hs-comment">-- | Inserts a key\/value mapping into the hash table.</span>
<a name="line-343"></a><span class="hs-comment">--</span>
<a name="line-344"></a><span class="hs-comment">-- Note that 'insert' doesn't remove the old entry from the table -</span>
<a name="line-345"></a><span class="hs-comment">-- the behaviour is like an association list, where 'lookup' returns</span>
<a name="line-346"></a><span class="hs-comment">-- the most-recently-inserted mapping for a key in the table.  The</span>
<a name="line-347"></a><span class="hs-comment">-- reason for this is to keep 'insert' as efficient as possible.  If</span>
<a name="line-348"></a><span class="hs-comment">-- you need to update a mapping, then we provide 'update'.</span>
<a name="line-349"></a><span class="hs-comment">--</span>
<a name="line-350"></a><span class="hs-definition">insert</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">HashTable</span> <span class="hs-varid">key</span> <span class="hs-varid">val</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">key</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">val</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">IO</span> <span class="hs-conid">()</span>
<a name="line-351"></a>
<a name="line-352"></a><span class="hs-definition">insert</span> <span class="hs-varid">ht</span> <span class="hs-varid">key</span> <span class="hs-varid">val</span> <span class="hs-keyglyph">=</span>
<a name="line-353"></a>  <span class="hs-varid">updatingBucket</span> <span class="hs-conid">CanInsert</span> <span class="hs-layout">(</span><span class="hs-keyglyph">\</span><span class="hs-varid">bucket</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-layout">(</span><span class="hs-varid">key</span><span class="hs-layout">,</span><span class="hs-varid">val</span><span class="hs-layout">)</span><span class="hs-conop">:</span><span class="hs-varid">bucket</span><span class="hs-layout">,</span> <span class="hs-num">1</span><span class="hs-layout">,</span> <span class="hs-conid">()</span><span class="hs-layout">)</span><span class="hs-layout">)</span> <span class="hs-varid">ht</span> <span class="hs-varid">key</span>
<a name="line-354"></a>
<a name="line-355"></a>
<a name="line-356"></a><span class="hs-comment">-- ------------------------------------------------------------</span>
<a name="line-357"></a><span class="hs-comment">-- The core of the implementation is lurking down here, in findBucket,</span>
<a name="line-358"></a><span class="hs-comment">-- updatingBucket, and expandHashTable.</span>
<a name="line-359"></a>
<a name="line-360"></a><a name="tooBig"></a><span class="hs-definition">tooBig</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int32</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int32</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Bool</span>
<a name="line-361"></a><span class="hs-definition">tooBig</span> <span class="hs-varid">k</span> <span class="hs-varid">b</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">k</span><span class="hs-comment">-</span><span class="hs-varid">hYSTERESIS</span> <span class="hs-varop">&gt;</span> <span class="hs-varid">hLOAD</span> <span class="hs-varop">*</span> <span class="hs-varid">b</span>
<a name="line-362"></a>
<a name="line-363"></a><a name="bucketIndex"></a><span class="hs-comment">-- index of bucket within table.</span>
<a name="line-364"></a><span class="hs-definition">bucketIndex</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int32</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int32</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int32</span>
<a name="line-365"></a><span class="hs-definition">bucketIndex</span> <span class="hs-varid">mask</span> <span class="hs-varid">h</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">h</span> <span class="hs-varop">.&amp;.</span> <span class="hs-varid">mask</span>
<a name="line-366"></a>
<a name="line-367"></a><a name="findBucket"></a><span class="hs-comment">-- find the bucket in which the key belongs.</span>
<a name="line-368"></a><span class="hs-comment">-- returns (key equality, bucket index, bucket)</span>
<a name="line-369"></a><span class="hs-comment">--</span>
<a name="line-370"></a><span class="hs-comment">-- This rather grab-bag approach gives enough power to do pretty much</span>
<a name="line-371"></a><span class="hs-comment">-- any bucket-finding thing you might want to do.  We rely on inlining</span>
<a name="line-372"></a><span class="hs-comment">-- to throw away the stuff we don't want.  I'm proud to say that this</span>
<a name="line-373"></a><span class="hs-comment">-- plus updatingBucket below reduce most of the other definitions to a</span>
<a name="line-374"></a><span class="hs-comment">-- few lines of code, while actually speeding up the hashtable</span>
<a name="line-375"></a><span class="hs-comment">-- implementation when compared with a version which does everything</span>
<a name="line-376"></a><span class="hs-comment">-- from scratch.</span>
<a name="line-377"></a><span class="hs-comment">{-# INLINE findBucket #-}</span>
<a name="line-378"></a><span class="hs-definition">findBucket</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">HashTable</span> <span class="hs-varid">key</span> <span class="hs-varid">val</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">key</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">IO</span> <span class="hs-layout">(</span><span class="hs-conid">HT</span> <span class="hs-varid">key</span> <span class="hs-varid">val</span><span class="hs-layout">,</span> <span class="hs-conid">Int32</span><span class="hs-layout">,</span> <span class="hs-keyglyph">[</span><span class="hs-layout">(</span><span class="hs-varid">key</span><span class="hs-layout">,</span><span class="hs-varid">val</span><span class="hs-layout">)</span><span class="hs-keyglyph">]</span><span class="hs-layout">)</span>
<a name="line-379"></a><span class="hs-definition">findBucket</span> <span class="hs-conid">HashTable</span><span class="hs-layout">{</span> <span class="hs-varid">tab</span><span class="hs-keyglyph">=</span><span class="hs-varid">ref</span><span class="hs-layout">,</span> <span class="hs-varid">hash_fn</span><span class="hs-keyglyph">=</span><span class="hs-varid">hash</span><span class="hs-layout">}</span> <span class="hs-varid">key</span> <span class="hs-keyglyph">=</span> <span class="hs-keyword">do</span>
<a name="line-380"></a>  <span class="hs-varid">table</span><span class="hs-keyglyph">@</span><span class="hs-conid">HT</span><span class="hs-layout">{</span> <span class="hs-varid">buckets</span><span class="hs-keyglyph">=</span><span class="hs-varid">bkts</span><span class="hs-layout">,</span> <span class="hs-varid">bmask</span><span class="hs-keyglyph">=</span><span class="hs-varid">b</span> <span class="hs-layout">}</span> <span class="hs-keyglyph">&lt;-</span> <span class="hs-varid">readIORef</span> <span class="hs-varid">ref</span>
<a name="line-381"></a>  <span class="hs-keyword">let</span> <span class="hs-varid">indx</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">bucketIndex</span> <span class="hs-varid">b</span> <span class="hs-layout">(</span><span class="hs-varid">hash</span> <span class="hs-varid">key</span><span class="hs-layout">)</span>
<a name="line-382"></a>  <span class="hs-varid">bucket</span> <span class="hs-keyglyph">&lt;-</span> <span class="hs-varid">readHTArray</span> <span class="hs-varid">bkts</span> <span class="hs-varid">indx</span>
<a name="line-383"></a>  <span class="hs-varid">return</span> <span class="hs-layout">(</span><span class="hs-varid">table</span><span class="hs-layout">,</span> <span class="hs-varid">indx</span><span class="hs-layout">,</span> <span class="hs-varid">bucket</span><span class="hs-layout">)</span>
<a name="line-384"></a>
<a name="line-385"></a><a name="Inserts"></a><span class="hs-keyword">data</span> <span class="hs-conid">Inserts</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">CanInsert</span>
<a name="line-386"></a>             <span class="hs-keyglyph">|</span> <span class="hs-conid">Can'tInsert</span>
<a name="line-387"></a>             <span class="hs-keyword">deriving</span> <span class="hs-layout">(</span><span class="hs-conid">Eq</span><span class="hs-layout">)</span>
<a name="line-388"></a>
<a name="line-389"></a><span class="hs-comment">-- updatingBucket is the real workhorse of all single-element table</span>
<a name="line-390"></a><span class="hs-comment">-- updates.  It takes a hashtable and a key, along with a function</span>
<a name="line-391"></a><span class="hs-comment">-- describing what to do with the bucket in which that key belongs.  A</span>
<a name="line-392"></a><span class="hs-comment">-- flag indicates whether this function may perform table insertions.</span>
<a name="line-393"></a><span class="hs-comment">-- The function returns the new contents of the bucket, the number of</span>
<a name="line-394"></a><span class="hs-comment">-- bucket entries inserted (negative if entries were deleted), and a</span>
<a name="line-395"></a><span class="hs-comment">-- value which becomes the return value for the function as a whole.</span>
<a name="line-396"></a><span class="hs-comment">-- The table sizing is enforced here, calling out to expandSubTable as</span>
<a name="line-397"></a><span class="hs-comment">-- necessary.</span>
<a name="line-398"></a>
<a name="line-399"></a><span class="hs-comment">-- This function is intended to be inlined and specialized for every</span>
<a name="line-400"></a><span class="hs-comment">-- calling context (eg every provided bucketFn).</span>
<a name="line-401"></a><span class="hs-comment">{-# INLINE updatingBucket #-}</span>
<a name="line-402"></a>
<a name="line-403"></a><a name="updatingBucket"></a><span class="hs-definition">updatingBucket</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Inserts</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-keyglyph">[</span><span class="hs-layout">(</span><span class="hs-varid">key</span><span class="hs-layout">,</span><span class="hs-varid">val</span><span class="hs-layout">)</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-keyglyph">[</span><span class="hs-layout">(</span><span class="hs-varid">key</span><span class="hs-layout">,</span><span class="hs-varid">val</span><span class="hs-layout">)</span><span class="hs-keyglyph">]</span><span class="hs-layout">,</span> <span class="hs-conid">Int32</span><span class="hs-layout">,</span> <span class="hs-varid">a</span><span class="hs-layout">)</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span>
<a name="line-404"></a>                  <span class="hs-conid">HashTable</span> <span class="hs-varid">key</span> <span class="hs-varid">val</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">key</span> <span class="hs-keyglyph">-&gt;</span>
<a name="line-405"></a>                  <span class="hs-conid">IO</span> <span class="hs-varid">a</span>
<a name="line-406"></a><span class="hs-definition">updatingBucket</span> <span class="hs-varid">canEnlarge</span> <span class="hs-varid">bucketFn</span>
<a name="line-407"></a>               <span class="hs-varid">ht</span><span class="hs-keyglyph">@</span><span class="hs-conid">HashTable</span><span class="hs-layout">{</span> <span class="hs-varid">tab</span><span class="hs-keyglyph">=</span><span class="hs-varid">ref</span><span class="hs-layout">,</span> <span class="hs-varid">hash_fn</span><span class="hs-keyglyph">=</span><span class="hs-varid">hash</span> <span class="hs-layout">}</span> <span class="hs-varid">key</span> <span class="hs-keyglyph">=</span> <span class="hs-keyword">do</span>
<a name="line-408"></a>  <span class="hs-layout">(</span><span class="hs-varid">table</span><span class="hs-keyglyph">@</span><span class="hs-conid">HT</span><span class="hs-layout">{</span> <span class="hs-varid">kcount</span><span class="hs-keyglyph">=</span><span class="hs-varid">k</span><span class="hs-layout">,</span> <span class="hs-varid">buckets</span><span class="hs-keyglyph">=</span><span class="hs-varid">bkts</span><span class="hs-layout">,</span> <span class="hs-varid">bmask</span><span class="hs-keyglyph">=</span><span class="hs-varid">b</span> <span class="hs-layout">}</span><span class="hs-layout">,</span>
<a name="line-409"></a>   <span class="hs-varid">indx</span><span class="hs-layout">,</span> <span class="hs-varid">bckt</span><span class="hs-layout">)</span> <span class="hs-keyglyph">&lt;-</span> <span class="hs-varid">findBucket</span> <span class="hs-varid">ht</span> <span class="hs-varid">key</span>
<a name="line-410"></a>  <span class="hs-layout">(</span><span class="hs-varid">bckt'</span><span class="hs-layout">,</span> <span class="hs-varid">inserts</span><span class="hs-layout">,</span> <span class="hs-varid">result</span><span class="hs-layout">)</span> <span class="hs-keyglyph">&lt;-</span> <span class="hs-varid">return</span> <span class="hs-varop">$</span> <span class="hs-varid">bucketFn</span> <span class="hs-varid">bckt</span>
<a name="line-411"></a>  <span class="hs-keyword">let</span> <span class="hs-varid">k'</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">k</span> <span class="hs-varop">+</span> <span class="hs-varid">inserts</span>
<a name="line-412"></a>      <span class="hs-varid">table1</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">table</span> <span class="hs-layout">{</span> <span class="hs-varid">kcount</span><span class="hs-keyglyph">=</span><span class="hs-varid">k'</span> <span class="hs-layout">}</span>
<a name="line-413"></a>  <span class="hs-varid">writeMutArray</span> <span class="hs-varid">bkts</span> <span class="hs-varid">indx</span> <span class="hs-varid">bckt'</span>
<a name="line-414"></a>  <span class="hs-varid">table2</span> <span class="hs-keyglyph">&lt;-</span> <span class="hs-keyword">if</span> <span class="hs-varid">canEnlarge</span> <span class="hs-varop">==</span> <span class="hs-conid">CanInsert</span> <span class="hs-varop">&amp;&amp;</span> <span class="hs-varid">inserts</span> <span class="hs-varop">&gt;</span> <span class="hs-num">0</span> <span class="hs-keyword">then</span> <span class="hs-keyword">do</span>
<a name="line-415"></a>               <span class="hs-varid">recordIns</span> <span class="hs-varid">inserts</span> <span class="hs-varid">k'</span> <span class="hs-varid">bckt'</span>
<a name="line-416"></a>               <span class="hs-keyword">if</span> <span class="hs-varid">tooBig</span> <span class="hs-varid">k'</span> <span class="hs-varid">b</span>
<a name="line-417"></a>                  <span class="hs-keyword">then</span> <span class="hs-varid">expandHashTable</span> <span class="hs-varid">hash</span> <span class="hs-varid">table1</span>
<a name="line-418"></a>                  <span class="hs-keyword">else</span> <span class="hs-varid">return</span> <span class="hs-varid">table1</span>
<a name="line-419"></a>            <span class="hs-keyword">else</span> <span class="hs-varid">return</span> <span class="hs-varid">table1</span>
<a name="line-420"></a>  <span class="hs-varid">writeIORef</span> <span class="hs-varid">ref</span> <span class="hs-varid">table2</span>
<a name="line-421"></a>  <span class="hs-varid">return</span> <span class="hs-varid">result</span>
<a name="line-422"></a>
<a name="line-423"></a><a name="expandHashTable"></a><span class="hs-definition">expandHashTable</span> <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-varid">key</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int32</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">HT</span> <span class="hs-varid">key</span> <span class="hs-varid">val</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">IO</span> <span class="hs-layout">(</span><span class="hs-conid">HT</span> <span class="hs-varid">key</span> <span class="hs-varid">val</span><span class="hs-layout">)</span>
<a name="line-424"></a><span class="hs-definition">expandHashTable</span> <span class="hs-varid">hash</span> <span class="hs-varid">table</span><span class="hs-keyglyph">@</span><span class="hs-conid">HT</span><span class="hs-layout">{</span> <span class="hs-varid">buckets</span><span class="hs-keyglyph">=</span><span class="hs-varid">bkts</span><span class="hs-layout">,</span> <span class="hs-varid">bmask</span><span class="hs-keyglyph">=</span><span class="hs-varid">mask</span> <span class="hs-layout">}</span> <span class="hs-keyglyph">=</span> <span class="hs-keyword">do</span>
<a name="line-425"></a>   <span class="hs-keyword">let</span>
<a name="line-426"></a>      <span class="hs-varid">oldsize</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">mask</span> <span class="hs-varop">+</span> <span class="hs-num">1</span>
<a name="line-427"></a>      <span class="hs-varid">newmask</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">mask</span> <span class="hs-varop">+</span> <span class="hs-varid">mask</span> <span class="hs-varop">+</span> <span class="hs-num">1</span>
<a name="line-428"></a>   <span class="hs-varid">recordResize</span> <span class="hs-varid">oldsize</span> <span class="hs-layout">(</span><span class="hs-varid">newmask</span><span class="hs-varop">+</span><span class="hs-num">1</span><span class="hs-layout">)</span>
<a name="line-429"></a>   <span class="hs-comment">--</span>
<a name="line-430"></a>   <span class="hs-keyword">if</span> <span class="hs-varid">newmask</span> <span class="hs-varop">&gt;</span> <span class="hs-varid">tABLE_MAX</span><span class="hs-comment">-</span><span class="hs-num">1</span>
<a name="line-431"></a>      <span class="hs-keyword">then</span> <span class="hs-varid">return</span> <span class="hs-varid">table</span>
<a name="line-432"></a>      <span class="hs-keyword">else</span> <span class="hs-keyword">do</span>
<a name="line-433"></a>   <span class="hs-comment">--</span>
<a name="line-434"></a>    <span class="hs-varid">newbkts</span> <span class="hs-keyglyph">&lt;-</span> <span class="hs-varid">newMutArray</span> <span class="hs-layout">(</span><span class="hs-num">0</span><span class="hs-layout">,</span><span class="hs-varid">newmask</span><span class="hs-layout">)</span> <span class="hs-conid">[]</span>
<a name="line-435"></a>
<a name="line-436"></a>    <span class="hs-keyword">let</span>
<a name="line-437"></a>     <span class="hs-varid">splitBucket</span> <span class="hs-varid">oldindex</span> <span class="hs-keyglyph">=</span> <span class="hs-keyword">do</span>
<a name="line-438"></a>       <span class="hs-varid">bucket</span> <span class="hs-keyglyph">&lt;-</span> <span class="hs-varid">readHTArray</span> <span class="hs-varid">bkts</span> <span class="hs-varid">oldindex</span>
<a name="line-439"></a>       <span class="hs-keyword">let</span> <span class="hs-layout">(</span><span class="hs-varid">oldb</span><span class="hs-layout">,</span><span class="hs-varid">newb</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span>
<a name="line-440"></a>              <span class="hs-varid">partition</span> <span class="hs-layout">(</span><span class="hs-layout">(</span><span class="hs-varid">oldindex</span><span class="hs-varop">==</span><span class="hs-layout">)</span><span class="hs-varop">.</span> <span class="hs-varid">bucketIndex</span> <span class="hs-varid">newmask</span> <span class="hs-varop">.</span> <span class="hs-varid">hash</span> <span class="hs-varop">.</span> <span class="hs-varid">fst</span><span class="hs-layout">)</span> <span class="hs-varid">bucket</span>
<a name="line-441"></a>       <span class="hs-varid">writeMutArray</span> <span class="hs-varid">newbkts</span> <span class="hs-varid">oldindex</span> <span class="hs-varid">oldb</span>
<a name="line-442"></a>       <span class="hs-varid">writeMutArray</span> <span class="hs-varid">newbkts</span> <span class="hs-layout">(</span><span class="hs-varid">oldindex</span> <span class="hs-varop">+</span> <span class="hs-varid">oldsize</span><span class="hs-layout">)</span> <span class="hs-varid">newb</span>
<a name="line-443"></a>    <span class="hs-varid">mapM_</span> <span class="hs-varid">splitBucket</span> <span class="hs-keyglyph">[</span><span class="hs-num">0</span><span class="hs-keyglyph">..</span><span class="hs-varid">mask</span><span class="hs-keyglyph">]</span>
<a name="line-444"></a>
<a name="line-445"></a>    <span class="hs-varid">return</span> <span class="hs-layout">(</span> <span class="hs-varid">table</span><span class="hs-layout">{</span> <span class="hs-varid">buckets</span><span class="hs-keyglyph">=</span><span class="hs-varid">newbkts</span><span class="hs-layout">,</span> <span class="hs-varid">bmask</span><span class="hs-keyglyph">=</span><span class="hs-varid">newmask</span> <span class="hs-layout">}</span> <span class="hs-layout">)</span>
<a name="line-446"></a>
<a name="line-447"></a><span class="hs-comment">-- -----------------------------------------------------------------------------</span>
<a name="line-448"></a><span class="hs-comment">-- Deleting a mapping from the hash table</span>
<a name="line-449"></a>
<a name="line-450"></a><a name="deleteBucket"></a><span class="hs-comment">-- Remove a key from a bucket</span>
<a name="line-451"></a><span class="hs-definition">deleteBucket</span> <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-varid">key</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Bool</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyglyph">[</span><span class="hs-layout">(</span><span class="hs-varid">key</span><span class="hs-layout">,</span><span class="hs-varid">val</span><span class="hs-layout">)</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-keyglyph">[</span><span class="hs-layout">(</span><span class="hs-varid">key</span><span class="hs-layout">,</span> <span class="hs-varid">val</span><span class="hs-layout">)</span><span class="hs-keyglyph">]</span><span class="hs-layout">,</span> <span class="hs-conid">Int32</span><span class="hs-layout">,</span> <span class="hs-conid">()</span><span class="hs-layout">)</span>
<a name="line-452"></a><span class="hs-definition">deleteBucket</span> <span class="hs-keyword">_</span>   <span class="hs-conid">[]</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">(</span><span class="hs-conid">[]</span><span class="hs-layout">,</span><span class="hs-num">0</span><span class="hs-layout">,</span><span class="hs-conid">()</span><span class="hs-layout">)</span>
<a name="line-453"></a><span class="hs-definition">deleteBucket</span> <span class="hs-varid">del</span> <span class="hs-layout">(</span><span class="hs-varid">pair</span><span class="hs-keyglyph">@</span><span class="hs-layout">(</span><span class="hs-varid">k</span><span class="hs-layout">,</span><span class="hs-keyword">_</span><span class="hs-layout">)</span><span class="hs-conop">:</span><span class="hs-varid">bucket</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span>
<a name="line-454"></a>  <span class="hs-keyword">case</span> <span class="hs-varid">deleteBucket</span> <span class="hs-varid">del</span> <span class="hs-varid">bucket</span> <span class="hs-keyword">of</span>
<a name="line-455"></a>    <span class="hs-layout">(</span><span class="hs-varid">bucket'</span><span class="hs-layout">,</span> <span class="hs-varid">dels</span><span class="hs-layout">,</span> <span class="hs-keyword">_</span><span class="hs-layout">)</span> <span class="hs-keyglyph">|</span> <span class="hs-varid">del</span> <span class="hs-varid">k</span>     <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">dels'</span> <span class="hs-varop">`seq`</span> <span class="hs-layout">(</span><span class="hs-varid">bucket'</span><span class="hs-layout">,</span> <span class="hs-varid">dels'</span><span class="hs-layout">,</span> <span class="hs-conid">()</span><span class="hs-layout">)</span>
<a name="line-456"></a>                       <span class="hs-keyglyph">|</span> <span class="hs-varid">otherwise</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-varid">pair</span><span class="hs-conop">:</span><span class="hs-varid">bucket'</span><span class="hs-layout">,</span> <span class="hs-varid">dels</span><span class="hs-layout">,</span> <span class="hs-conid">()</span><span class="hs-layout">)</span>
<a name="line-457"></a>      <span class="hs-keyword">where</span> <span class="hs-varid">dels'</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">dels</span> <span class="hs-comment">-</span> <span class="hs-num">1</span>
<a name="line-458"></a>
<a name="line-459"></a><a name="delete"></a><span class="hs-comment">-- | Remove an entry from the hash table.</span>
<a name="line-460"></a><span class="hs-definition">delete</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">HashTable</span> <span class="hs-varid">key</span> <span class="hs-varid">val</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">key</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">IO</span> <span class="hs-conid">()</span>
<a name="line-461"></a>
<a name="line-462"></a><span class="hs-definition">delete</span> <span class="hs-varid">ht</span><span class="hs-keyglyph">@</span><span class="hs-conid">HashTable</span><span class="hs-layout">{</span> <span class="hs-varid">cmp</span><span class="hs-keyglyph">=</span><span class="hs-varid">eq</span> <span class="hs-layout">}</span> <span class="hs-varid">key</span> <span class="hs-keyglyph">=</span>
<a name="line-463"></a>  <span class="hs-varid">updatingBucket</span> <span class="hs-conid">Can'tInsert</span> <span class="hs-layout">(</span><span class="hs-varid">deleteBucket</span> <span class="hs-layout">(</span><span class="hs-varid">eq</span> <span class="hs-varid">key</span><span class="hs-layout">)</span><span class="hs-layout">)</span> <span class="hs-varid">ht</span> <span class="hs-varid">key</span>
<a name="line-464"></a>
<a name="line-465"></a><span class="hs-comment">-- -----------------------------------------------------------------------------</span>
<a name="line-466"></a><span class="hs-comment">-- Updating a mapping in the hash table</span>
<a name="line-467"></a>
<a name="line-468"></a><a name="update"></a><span class="hs-comment">-- | Updates an entry in the hash table, returning 'True' if there was</span>
<a name="line-469"></a><span class="hs-comment">-- already an entry for this key, or 'False' otherwise.  After 'update'</span>
<a name="line-470"></a><span class="hs-comment">-- there will always be exactly one entry for the given key in the table.</span>
<a name="line-471"></a><span class="hs-comment">--</span>
<a name="line-472"></a><span class="hs-comment">-- 'insert' is more efficient than 'update' if you don't care about</span>
<a name="line-473"></a><span class="hs-comment">-- multiple entries, or you know for sure that multiple entries can't</span>
<a name="line-474"></a><span class="hs-comment">-- occur.  However, 'update' is more efficient than 'delete' followed</span>
<a name="line-475"></a><span class="hs-comment">-- by 'insert'.</span>
<a name="line-476"></a><span class="hs-definition">update</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">HashTable</span> <span class="hs-varid">key</span> <span class="hs-varid">val</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">key</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">val</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">IO</span> <span class="hs-conid">Bool</span>
<a name="line-477"></a>
<a name="line-478"></a><span class="hs-definition">update</span> <span class="hs-varid">ht</span><span class="hs-keyglyph">@</span><span class="hs-conid">HashTable</span><span class="hs-layout">{</span> <span class="hs-varid">cmp</span><span class="hs-keyglyph">=</span><span class="hs-varid">eq</span> <span class="hs-layout">}</span> <span class="hs-varid">key</span> <span class="hs-varid">val</span> <span class="hs-keyglyph">=</span>
<a name="line-479"></a>  <span class="hs-varid">updatingBucket</span> <span class="hs-conid">CanInsert</span>
<a name="line-480"></a>    <span class="hs-layout">(</span><span class="hs-keyglyph">\</span><span class="hs-varid">bucket</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyword">let</span> <span class="hs-layout">(</span><span class="hs-varid">bucket'</span><span class="hs-layout">,</span> <span class="hs-varid">dels</span><span class="hs-layout">,</span> <span class="hs-keyword">_</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">deleteBucket</span> <span class="hs-layout">(</span><span class="hs-varid">eq</span> <span class="hs-varid">key</span><span class="hs-layout">)</span> <span class="hs-varid">bucket</span>
<a name="line-481"></a>                <span class="hs-keyword">in</span>  <span class="hs-layout">(</span><span class="hs-layout">(</span><span class="hs-varid">key</span><span class="hs-layout">,</span><span class="hs-varid">val</span><span class="hs-layout">)</span><span class="hs-conop">:</span><span class="hs-varid">bucket'</span><span class="hs-layout">,</span> <span class="hs-num">1</span><span class="hs-varop">+</span><span class="hs-varid">dels</span><span class="hs-layout">,</span> <span class="hs-varid">dels</span><span class="hs-varop">/=</span><span class="hs-num">0</span><span class="hs-layout">)</span><span class="hs-layout">)</span>
<a name="line-482"></a>    <span class="hs-varid">ht</span> <span class="hs-varid">key</span>
<a name="line-483"></a>
<a name="line-484"></a><span class="hs-comment">-- -----------------------------------------------------------------------------</span>
<a name="line-485"></a><span class="hs-comment">-- Looking up an entry in the hash table</span>
<a name="line-486"></a>
<a name="line-487"></a><a name="lookup"></a><span class="hs-comment">-- | Looks up the value of a key in the hash table.</span>
<a name="line-488"></a><span class="hs-definition">lookup</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">HashTable</span> <span class="hs-varid">key</span> <span class="hs-varid">val</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">key</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">IO</span> <span class="hs-layout">(</span><span class="hs-conid">Maybe</span> <span class="hs-varid">val</span><span class="hs-layout">)</span>
<a name="line-489"></a>
<a name="line-490"></a><span class="hs-definition">lookup</span> <span class="hs-varid">ht</span><span class="hs-keyglyph">@</span><span class="hs-conid">HashTable</span><span class="hs-layout">{</span> <span class="hs-varid">cmp</span><span class="hs-keyglyph">=</span><span class="hs-varid">eq</span> <span class="hs-layout">}</span> <span class="hs-varid">key</span> <span class="hs-keyglyph">=</span> <span class="hs-keyword">do</span>
<a name="line-491"></a>  <span class="hs-varid">recordLookup</span>
<a name="line-492"></a>  <span class="hs-layout">(</span><span class="hs-keyword">_</span><span class="hs-layout">,</span> <span class="hs-keyword">_</span><span class="hs-layout">,</span> <span class="hs-varid">bucket</span><span class="hs-layout">)</span> <span class="hs-keyglyph">&lt;-</span> <span class="hs-varid">findBucket</span> <span class="hs-varid">ht</span> <span class="hs-varid">key</span>
<a name="line-493"></a>  <span class="hs-keyword">let</span> <span class="hs-varid">firstHit</span> <span class="hs-layout">(</span><span class="hs-varid">k</span><span class="hs-layout">,</span><span class="hs-varid">v</span><span class="hs-layout">)</span> <span class="hs-varid">r</span> <span class="hs-keyglyph">|</span> <span class="hs-varid">eq</span> <span class="hs-varid">key</span> <span class="hs-varid">k</span>  <span class="hs-keyglyph">=</span> <span class="hs-conid">Just</span> <span class="hs-varid">v</span>
<a name="line-494"></a>                       <span class="hs-keyglyph">|</span> <span class="hs-varid">otherwise</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">r</span>
<a name="line-495"></a>  <span class="hs-varid">return</span> <span class="hs-layout">(</span><span class="hs-varid">foldr</span> <span class="hs-varid">firstHit</span> <span class="hs-conid">Nothing</span> <span class="hs-varid">bucket</span><span class="hs-layout">)</span>
<a name="line-496"></a>
<a name="line-497"></a><span class="hs-comment">-- -----------------------------------------------------------------------------</span>
<a name="line-498"></a><span class="hs-comment">-- Converting to/from lists</span>
<a name="line-499"></a>
<a name="line-500"></a><a name="fromList"></a><span class="hs-comment">-- | Convert a list of key\/value pairs into a hash table.  Equality on keys</span>
<a name="line-501"></a><span class="hs-comment">-- is taken from the Eq instance for the key type.</span>
<a name="line-502"></a><span class="hs-comment">--</span>
<a name="line-503"></a><span class="hs-definition">fromList</span> <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-conid">Eq</span> <span class="hs-varid">key</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=&gt;</span> <span class="hs-layout">(</span><span class="hs-varid">key</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int32</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyglyph">[</span><span class="hs-layout">(</span><span class="hs-varid">key</span><span class="hs-layout">,</span><span class="hs-varid">val</span><span class="hs-layout">)</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">IO</span> <span class="hs-layout">(</span><span class="hs-conid">HashTable</span> <span class="hs-varid">key</span> <span class="hs-varid">val</span><span class="hs-layout">)</span>
<a name="line-504"></a><span class="hs-definition">fromList</span> <span class="hs-varid">hash</span> <span class="hs-varid">list</span> <span class="hs-keyglyph">=</span> <span class="hs-keyword">do</span>
<a name="line-505"></a>  <span class="hs-varid">table</span> <span class="hs-keyglyph">&lt;-</span> <span class="hs-varid">new</span> <span class="hs-layout">(</span><span class="hs-varop">==</span><span class="hs-layout">)</span> <span class="hs-varid">hash</span>
<a name="line-506"></a>  <span class="hs-varid">sequence_</span> <span class="hs-keyglyph">[</span> <span class="hs-varid">insert</span> <span class="hs-varid">table</span> <span class="hs-varid">k</span> <span class="hs-varid">v</span> <span class="hs-keyglyph">|</span> <span class="hs-layout">(</span><span class="hs-varid">k</span><span class="hs-layout">,</span><span class="hs-varid">v</span><span class="hs-layout">)</span> <span class="hs-keyglyph">&lt;-</span> <span class="hs-varid">list</span> <span class="hs-keyglyph">]</span>
<a name="line-507"></a>  <span class="hs-varid">return</span> <span class="hs-varid">table</span>
<a name="line-508"></a>
<a name="line-509"></a><a name="toList"></a><span class="hs-comment">-- | Converts a hash table to a list of key\/value pairs.</span>
<a name="line-510"></a><span class="hs-comment">--</span>
<a name="line-511"></a><span class="hs-definition">toList</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">HashTable</span> <span class="hs-varid">key</span> <span class="hs-varid">val</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">IO</span> <span class="hs-keyglyph">[</span><span class="hs-layout">(</span><span class="hs-varid">key</span><span class="hs-layout">,</span><span class="hs-varid">val</span><span class="hs-layout">)</span><span class="hs-keyglyph">]</span>
<a name="line-512"></a><span class="hs-definition">toList</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">mapReduce</span> <span class="hs-varid">id</span> <span class="hs-varid">concat</span>
<a name="line-513"></a>
<a name="line-514"></a><a name="mapReduce"></a><span class="hs-comment">{-# INLINE mapReduce #-}</span>
<a name="line-515"></a><span class="hs-definition">mapReduce</span> <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-keyglyph">[</span><span class="hs-layout">(</span><span class="hs-varid">key</span><span class="hs-layout">,</span><span class="hs-varid">val</span><span class="hs-layout">)</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">r</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-keyglyph">[</span><span class="hs-varid">r</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">r</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">HashTable</span> <span class="hs-varid">key</span> <span class="hs-varid">val</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">IO</span> <span class="hs-varid">r</span>
<a name="line-516"></a><span class="hs-definition">mapReduce</span> <span class="hs-varid">m</span> <span class="hs-varid">r</span> <span class="hs-conid">HashTable</span><span class="hs-layout">{</span> <span class="hs-varid">tab</span><span class="hs-keyglyph">=</span><span class="hs-varid">ref</span> <span class="hs-layout">}</span> <span class="hs-keyglyph">=</span> <span class="hs-keyword">do</span>
<a name="line-517"></a>  <span class="hs-conid">HT</span><span class="hs-layout">{</span> <span class="hs-varid">buckets</span><span class="hs-keyglyph">=</span><span class="hs-varid">bckts</span><span class="hs-layout">,</span> <span class="hs-varid">bmask</span><span class="hs-keyglyph">=</span><span class="hs-varid">b</span> <span class="hs-layout">}</span> <span class="hs-keyglyph">&lt;-</span> <span class="hs-varid">readIORef</span> <span class="hs-varid">ref</span>
<a name="line-518"></a>  <span class="hs-varid">fmap</span> <span class="hs-varid">r</span> <span class="hs-layout">(</span><span class="hs-varid">mapM</span> <span class="hs-layout">(</span><span class="hs-varid">fmap</span> <span class="hs-varid">m</span> <span class="hs-varop">.</span> <span class="hs-varid">readHTArray</span> <span class="hs-varid">bckts</span><span class="hs-layout">)</span> <span class="hs-keyglyph">[</span><span class="hs-num">0</span><span class="hs-keyglyph">..</span><span class="hs-varid">b</span><span class="hs-keyglyph">]</span><span class="hs-layout">)</span>
<a name="line-519"></a>
<a name="line-520"></a><span class="hs-comment">-- -----------------------------------------------------------------------------</span>
<a name="line-521"></a><span class="hs-comment">-- Diagnostics</span>
<a name="line-522"></a>
<a name="line-523"></a><a name="longestChain"></a><span class="hs-comment">-- | This function is useful for determining whether your hash</span>
<a name="line-524"></a><span class="hs-comment">-- function is working well for your data set.  It returns the longest</span>
<a name="line-525"></a><span class="hs-comment">-- chain of key\/value pairs in the hash table for which all the keys</span>
<a name="line-526"></a><span class="hs-comment">-- hash to the same bucket.  If this chain is particularly long (say,</span>
<a name="line-527"></a><span class="hs-comment">-- longer than 14 elements or so), then it might be a good idea to try</span>
<a name="line-528"></a><span class="hs-comment">-- a different hash function.</span>
<a name="line-529"></a><span class="hs-comment">--</span>
<a name="line-530"></a><span class="hs-definition">longestChain</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">HashTable</span> <span class="hs-varid">key</span> <span class="hs-varid">val</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">IO</span> <span class="hs-keyglyph">[</span><span class="hs-layout">(</span><span class="hs-varid">key</span><span class="hs-layout">,</span><span class="hs-varid">val</span><span class="hs-layout">)</span><span class="hs-keyglyph">]</span>
<a name="line-531"></a><span class="hs-definition">longestChain</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">mapReduce</span> <span class="hs-varid">id</span> <span class="hs-layout">(</span><span class="hs-varid">maximumBy</span> <span class="hs-varid">lengthCmp</span><span class="hs-layout">)</span>
<a name="line-532"></a>  <span class="hs-keyword">where</span> <span class="hs-varid">lengthCmp</span> <span class="hs-layout">(</span><span class="hs-keyword">_</span><span class="hs-conop">:</span><span class="hs-varid">x</span><span class="hs-layout">)</span><span class="hs-layout">(</span><span class="hs-keyword">_</span><span class="hs-conop">:</span><span class="hs-varid">y</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">lengthCmp</span> <span class="hs-varid">x</span> <span class="hs-varid">y</span>
<a name="line-533"></a>        <span class="hs-varid">lengthCmp</span> <span class="hs-conid">[]</span>   <span class="hs-conid">[]</span>    <span class="hs-keyglyph">=</span> <span class="hs-conid">EQ</span>
<a name="line-534"></a>        <span class="hs-varid">lengthCmp</span> <span class="hs-conid">[]</span>   <span class="hs-keyword">_</span>     <span class="hs-keyglyph">=</span> <span class="hs-conid">LT</span>
<a name="line-535"></a>        <span class="hs-varid">lengthCmp</span> <span class="hs-keyword">_</span>    <span class="hs-conid">[]</span>    <span class="hs-keyglyph">=</span> <span class="hs-conid">GT</span>
<a name="line-536"></a>
</pre></body>
</html>
