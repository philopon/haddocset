<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta><title>Data.Attoparsec.ByteString</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean"></link><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Data-Attoparsec-ByteString.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="../attoparsec-0.11.2.1/index.html">Contents</a></li><li><a href="../attoparsec-0.11.2.1/doc-index.html">Index</a></li></ul><p class="caption">attoparsec-0.11.2.1: Fast combinator parsing for bytestrings and text</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Portability</th><td>unknown</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Maintainer</th><td>bos@serpentine.com</td></tr><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Data.Attoparsec.ByteString</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="../attoparsec-0.11.2.1/#g:1">Differences from Parsec
</a></li><li><a href="../attoparsec-0.11.2.1/#g:2">Incremental input
</a></li><li><a href="../attoparsec-0.11.2.1/#g:3">Performance considerations
</a></li><li><a href="../attoparsec-0.11.2.1/#g:4">Parser types
</a></li><li><a href="../attoparsec-0.11.2.1/#g:5">Running parsers
</a><ul><li><a href="../attoparsec-0.11.2.1/#g:6">Result conversion
</a></li></ul></li><li><a href="../attoparsec-0.11.2.1/#g:7">Combinators
</a></li><li><a href="../attoparsec-0.11.2.1/#g:8">Parsing individual bytes
</a><ul><li><a href="../attoparsec-0.11.2.1/#g:9">Lookahead
</a></li><li><a href="../attoparsec-0.11.2.1/#g:10">Byte classes
</a></li></ul></li><li><a href="../attoparsec-0.11.2.1/#g:11">Efficient string handling
</a><ul><li><a href="../attoparsec-0.11.2.1/#g:12">Consume all remaining input
</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Simple, efficient combinator parsing for <code><a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a></code> strings,
 loosely based on the Parsec library.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">type</span> <a href="../attoparsec-0.11.2.1/#t:Parser">Parser</a> = <a href="../attoparsec-0.11.2.1/Data-Attoparsec-Types.html#t:Parser">Parser</a> <a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><span class="keyword">type</span> <a href="../attoparsec-0.11.2.1/#t:Result">Result</a> = <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:IResult">IResult</a> <a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><span class="keyword">data</span>  <a href="../attoparsec-0.11.2.1/#t:IResult">IResult</a> t r<ul class="subs"><li>= <a href="../attoparsec-0.11.2.1/#v:Fail">Fail</a> t [<a href="../base-4.6.0.1/Data-String.html#t:String">String</a>] <a href="../base-4.6.0.1/Data-String.html#t:String">String</a>  </li><li>| <a href="../attoparsec-0.11.2.1/#v:Partial">Partial</a> (t -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:IResult">IResult</a> t r)  </li><li>| <a href="../attoparsec-0.11.2.1/#v:Done">Done</a> t r  </li></ul></li><li class="src short"><a href="../attoparsec-0.11.2.1/#v:compareResults">compareResults</a> :: (<a href="../base-4.6.0.1/Data-Eq.html#t:Eq">Eq</a> t, <a href="../base-4.6.0.1/Data-Eq.html#t:Eq">Eq</a> r) =&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:IResult">IResult</a> t r -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:IResult">IResult</a> t r -&gt; <a href="../base-4.6.0.1/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../base-4.6.0.1/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="../attoparsec-0.11.2.1/#v:parse">parse</a> ::  <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> a -&gt; <a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Result">Result</a> a</li><li class="src short"><a href="../attoparsec-0.11.2.1/#v:feed">feed</a> ::  <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Result">Result</a> r -&gt; <a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Result">Result</a> r</li><li class="src short"><a href="../attoparsec-0.11.2.1/#v:parseOnly">parseOnly</a> ::  <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> a -&gt; <a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.6.0.1/Data-Either.html#t:Either">Either</a> <a href="../base-4.6.0.1/Data-String.html#t:String">String</a> a</li><li class="src short"><a href="../attoparsec-0.11.2.1/#v:parseWith">parseWith</a> :: <a href="../base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a> m =&gt; m <a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> a -&gt; <a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; m (<a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Result">Result</a> a)</li><li class="src short"><a href="../attoparsec-0.11.2.1/#v:parseTest">parseTest</a> :: <a href="../base-4.6.0.1/Text-Show.html#t:Show">Show</a> a =&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> a -&gt; <a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.6.0.1/System-IO.html#t:IO">IO</a> ()</li><li class="src short"><a href="../attoparsec-0.11.2.1/#v:maybeResult">maybeResult</a> ::  <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Result">Result</a> r -&gt; <a href="../base-4.6.0.1/Data-Maybe.html#t:Maybe">Maybe</a> r</li><li class="src short"><a href="../attoparsec-0.11.2.1/#v:eitherResult">eitherResult</a> ::  <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Result">Result</a> r -&gt; <a href="../base-4.6.0.1/Data-Either.html#t:Either">Either</a> <a href="../base-4.6.0.1/Data-String.html#t:String">String</a> r</li><li class="src short">module <a href="../attoparsec-0.11.2.1/Data-Attoparsec-Combinator.html">Data.Attoparsec.Combinator</a></li><li class="src short"><a href="../attoparsec-0.11.2.1/#v:word8">word8</a> :: <a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a></li><li class="src short"><a href="../attoparsec-0.11.2.1/#v:anyWord8">anyWord8</a> :: <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a></li><li class="src short"><a href="../attoparsec-0.11.2.1/#v:notWord8">notWord8</a> :: <a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a></li><li class="src short"><a href="../attoparsec-0.11.2.1/#v:satisfy">satisfy</a> :: (<a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.6.0.1/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a></li><li class="src short"><a href="../attoparsec-0.11.2.1/#v:satisfyWith">satisfyWith</a> ::  (<a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a> -&gt; a) -&gt; (a -&gt; <a href="../base-4.6.0.1/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> a</li><li class="src short"><a href="../attoparsec-0.11.2.1/#v:skip">skip</a> :: (<a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.6.0.1/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> ()</li><li class="src short"><a href="../attoparsec-0.11.2.1/#v:peekWord8">peekWord8</a> :: <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> (<a href="../base-4.6.0.1/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a>)</li><li class="src short"><a href="../attoparsec-0.11.2.1/#v:peekWord8-39-">peekWord8'</a> :: <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a></li><li class="src short"><a href="../attoparsec-0.11.2.1/#v:inClass">inClass</a> :: <a href="../base-4.6.0.1/Data-String.html#t:String">String</a> -&gt; <a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.6.0.1/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="../attoparsec-0.11.2.1/#v:notInClass">notInClass</a> :: <a href="../base-4.6.0.1/Data-String.html#t:String">String</a> -&gt; <a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.6.0.1/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="../attoparsec-0.11.2.1/#v:string">string</a> :: <a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="../attoparsec-0.11.2.1/#v:skipWhile">skipWhile</a> :: (<a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.6.0.1/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> ()</li><li class="src short"><a href="../attoparsec-0.11.2.1/#v:take">take</a> :: <a href="../base-4.6.0.1/Data-Int.html#t:Int">Int</a> -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="../attoparsec-0.11.2.1/#v:scan">scan</a> ::  s -&gt; (s -&gt; <a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.6.0.1/Data-Maybe.html#t:Maybe">Maybe</a> s) -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="../attoparsec-0.11.2.1/#v:takeWhile">takeWhile</a> :: (<a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.6.0.1/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="../attoparsec-0.11.2.1/#v:takeWhile1">takeWhile1</a> :: (<a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.6.0.1/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="../attoparsec-0.11.2.1/#v:takeTill">takeTill</a> :: (<a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.6.0.1/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="../attoparsec-0.11.2.1/#v:takeByteString">takeByteString</a> :: <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="../attoparsec-0.11.2.1/#v:takeLazyByteString">takeLazyByteString</a> :: <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../bytestring-0.10.0.2/Data-ByteString-Lazy.html#t:ByteString">ByteString</a></li></ul></div><div id="interface"><h1 id="g:1">Differences from Parsec
</h1><div class="doc"><p>Compared to Parsec 3, Attoparsec makes several tradeoffs.  It is
 not intended for, or ideal for, all possible uses.
</p><ul><li> While Attoparsec can consume input incrementally, Parsec cannot.
   Incremental input is a huge deal for efficient and secure network
   and system programming, since it gives much more control to users
   of the library over matters such as resource usage and the I/O
   model to use.
</li><li> Much of the performance advantage of Attoparsec is gained via
   high-performance parsers such as <code><a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#v:takeWhile">takeWhile</a></code> and <code><a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#v:string">string</a></code>.
   If you use complicated combinators that return lists of bytes or
   characters, there is less performance difference between the two
   libraries.
</li><li> Unlike Parsec 3, Attoparsec does not support being used as a
   monad transformer.
</li><li> Attoparsec is specialised to deal only with strict <code><a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a></code>
   input.  Efficiency concerns rule out both lists and lazy
   bytestrings.  The usual use for lazy bytestrings would be to
   allow consumption of very large input without a large footprint.
   For this need, Attoparsec's incremental input provides an
   excellent substitute, with much more control over when input
   takes place.  If you must use lazy bytestrings, see the <code>Lazy</code>
   module, which feeds lazy chunks to a regular parser.
</li><li> Parsec parsers can produce more helpful error messages than
   Attoparsec parsers.  This is a matter of focus: Attoparsec avoids
   the extra book-keeping in favour of higher performance.
</li></ul></div><h1 id="g:2">Incremental input
</h1><div class="doc"><p>Attoparsec supports incremental input, meaning that you can feed it
 a bytestring that represents only part of the expected total amount
 of data to parse. If your parser reaches the end of a fragment of
 input and could consume more input, it will suspend parsing and
 return a <code><a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#v:Partial">Partial</a></code> continuation.
</p><p>Supplying the <code><a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#v:Partial">Partial</a></code> continuation with another bytestring will
 resume parsing at the point where it was suspended. You must be
 prepared for the result of the resumed parse to be another
 <code><a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#v:Partial">Partial</a></code> continuation.
</p><p>To indicate that you have no more input, supply the <code><a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#v:Partial">Partial</a></code>
 continuation with an empty bytestring.
</p><p>Remember that some parsing combinators will not return a result
 until they reach the end of input.  They may thus cause <code><a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#v:Partial">Partial</a></code>
 results to be returned.
</p><p>If you do not need support for incremental input, consider using
 the <code><a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#v:parseOnly">parseOnly</a></code> function to run your parser.  It will never
 prompt for more input.
</p></div><h1 id="g:3">Performance considerations
</h1><div class="doc"><p>If you write an Attoparsec-based parser carefully, it can be
 realistic to expect it to perform within a factor of 2 of a
 hand-rolled C parser (measuring megabytes parsed per second).
</p><p>To actually achieve high performance, there are a few guidelines
 that it is useful to follow.
</p><p>Use the <code><a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a></code>-oriented parsers whenever possible,
 e.g. <code><a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#v:takeWhile1">takeWhile1</a></code> instead of <code><a href="../attoparsec-0.11.2.1/Data-Attoparsec-Combinator.html#v:many1">many1</a></code> <code><a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#v:anyWord8">anyWord8</a></code>.  There is
 about a factor of 100 difference in performance between the two
 kinds of parser.
</p><p>For very simple byte-testing predicates, write them by hand instead
 of using <code><a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#v:inClass">inClass</a></code> or <code><a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#v:notInClass">notInClass</a></code>.  For instance, both of
 these predicates test for an end-of-line byte, but the first is
 much faster than the second:
</p><pre>endOfLine_fast w = w == 13 || w == 10
endOfLine_slow   = inClass &quot;\r\n&quot;
</pre><p>Make active use of benchmarking and profiling tools to measure,
 find the problems with, and improve the performance of your parser.
</p></div><h1 id="g:4">Parser types
</h1><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Parser" class="def">Parser</a> = <a href="../attoparsec-0.11.2.1/Data-Attoparsec-Types.html#t:Parser">Parser</a> <a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a></p></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Result" class="def">Result</a> = <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:IResult">IResult</a> <a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a></p></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:IResult" class="def">IResult</a> t r </p><div class="doc"><p>The result of a parse.  This is parameterised over the type <code>t</code>
 of string that was processed.
</p><p>This type is an instance of <code><a href="../base-4.6.0.1/Control-Monad.html#t:Functor">Functor</a></code>, where <code><a href="../base-4.6.0.1/Control-Monad.html#v:fmap">fmap</a></code> transforms the
 value in a <code><a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#v:Done">Done</a></code> result.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Fail" class="def">Fail</a> t [<a href="../base-4.6.0.1/Data-String.html#t:String">String</a>] <a href="../base-4.6.0.1/Data-String.html#t:String">String</a></td><td class="doc"><p>The parse failed.  The <code>t</code> parameter is the
 input that had not yet been consumed when the
 failure occurred.  The <code>[</code><code><a href="../base-4.6.0.1/Data-String.html#t:String">String</a></code><code>]</code> is a list of
 contexts in which the error occurred.  The
 <code><a href="../base-4.6.0.1/Data-String.html#t:String">String</a></code> is the message describing the error, if
 any.
</p></td></tr><tr><td class="src"><a name="v:Partial" class="def">Partial</a> (t -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:IResult">IResult</a> t r)</td><td class="doc"><p>Supply this continuation with more input so that
 the parser can resume.  To indicate that no more
 input is available, use an empty string.
</p></td></tr><tr><td class="src"><a name="v:Done" class="def">Done</a> t r</td><td class="doc"><p>The parse succeeded.  The <code>t</code> parameter is the
 input that had not yet been consumed (if any) when
 the parse succeeded.
</p></td></tr></table></div><div class="subs instances"><p id="control.i:IResult" class="caption collapser" onclick="toggleSection('i:IResult')">Instances</p><div id="section.i:IResult" class="show"><table><tr><td class="src"><a href="../base-4.6.0.1/Control-Monad.html#t:Functor">Functor</a> (<a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:IResult">IResult</a> t)</td><td class="doc empty"> </td></tr><tr><td class="src">(<a href="../base-4.6.0.1/Text-Show.html#t:Show">Show</a> t, <a href="../base-4.6.0.1/Text-Show.html#t:Show">Show</a> r) =&gt; <a href="../base-4.6.0.1/Text-Show.html#t:Show">Show</a> (<a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:IResult">IResult</a> t r)</td><td class="doc empty"> </td></tr><tr><td class="src">(<a href="../deepseq-1.3.0.1/Control-DeepSeq.html#t:NFData">NFData</a> t, <a href="../deepseq-1.3.0.1/Control-DeepSeq.html#t:NFData">NFData</a> r) =&gt; <a href="../deepseq-1.3.0.1/Control-DeepSeq.html#t:NFData">NFData</a> (<a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:IResult">IResult</a> t r)</td><td class="doc empty"> </td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:compareResults" class="def">compareResults</a> :: (<a href="../base-4.6.0.1/Data-Eq.html#t:Eq">Eq</a> t, <a href="../base-4.6.0.1/Data-Eq.html#t:Eq">Eq</a> r) =&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:IResult">IResult</a> t r -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:IResult">IResult</a> t r -&gt; <a href="../base-4.6.0.1/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../base-4.6.0.1/Data-Bool.html#t:Bool">Bool</a></p><div class="doc"><p>Compare two <code><a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:IResult">IResult</a></code> values for equality.
</p><p>If both <code><a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:IResult">IResult</a></code>s are <code><a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#v:Partial">Partial</a></code>, the result will be <code><a href="../base-4.6.0.1/Data-Maybe.html#v:Nothing">Nothing</a></code>, as
 they are incomplete and hence their equality cannot be known.
 (This is why there is no <code><a href="../base-4.6.0.1/Data-Eq.html#t:Eq">Eq</a></code> instance for <code><a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:IResult">IResult</a></code>.)
</p></div></div><h1 id="g:5">Running parsers
</h1><div class="top"><p class="src"><a name="v:parse" class="def">parse</a> ::  <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> a -&gt; <a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Result">Result</a> a</p><div class="doc"><p>Run a parser.
</p></div></div><div class="top"><p class="src"><a name="v:feed" class="def">feed</a> ::  <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Result">Result</a> r -&gt; <a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Result">Result</a> r</p><div class="doc"><p>If a parser has returned a <code><a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#v:Partial">Partial</a></code> result, supply it with more
 input.
</p></div></div><div class="top"><p class="src"><a name="v:parseOnly" class="def">parseOnly</a> ::  <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> a -&gt; <a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.6.0.1/Data-Either.html#t:Either">Either</a> <a href="../base-4.6.0.1/Data-String.html#t:String">String</a> a</p><div class="doc"><p>Run a parser that cannot be resupplied via a <code><a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#v:Partial">Partial</a></code> result.
</p></div></div><div class="top"><p class="src"><a name="v:parseWith" class="def">parseWith</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty"> </td></tr><tr><td class="src">=&gt; m <a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a></td><td class="doc"><p>An action that will be executed to provide the parser
 with more input, if necessary.  The action must return an
 <code><a href="../bytestring-0.10.0.2/Data-ByteString.html#v:empty">empty</a></code> string when there is no more input available.
</p></td></tr><tr><td class="src">-&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> a</td><td class="doc empty"> </td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a></td><td class="doc"><p>Initial input for the parser.
</p></td></tr><tr><td class="src">-&gt; m (<a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Result">Result</a> a)</td><td class="doc empty"> </td></tr></table></div><div class="doc"><p>Run a parser with an initial input string, and a monadic action
 that can supply more input if needed.
</p></div></div><div class="top"><p class="src"><a name="v:parseTest" class="def">parseTest</a> :: <a href="../base-4.6.0.1/Text-Show.html#t:Show">Show</a> a =&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> a -&gt; <a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.6.0.1/System-IO.html#t:IO">IO</a> ()</p><div class="doc"><p>Run a parser and print its result to standard output.
</p></div></div><h2 id="g:6">Result conversion
</h2><div class="top"><p class="src"><a name="v:maybeResult" class="def">maybeResult</a> ::  <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Result">Result</a> r -&gt; <a href="../base-4.6.0.1/Data-Maybe.html#t:Maybe">Maybe</a> r</p><div class="doc"><p>Convert a <code><a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Result">Result</a></code> value to a <code><a href="../base-4.6.0.1/Data-Maybe.html#t:Maybe">Maybe</a></code> value. A <code><a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#v:Partial">Partial</a></code> result
 is treated as failure.
</p></div></div><div class="top"><p class="src"><a name="v:eitherResult" class="def">eitherResult</a> ::  <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Result">Result</a> r -&gt; <a href="../base-4.6.0.1/Data-Either.html#t:Either">Either</a> <a href="../base-4.6.0.1/Data-String.html#t:String">String</a> r</p><div class="doc"><p>Convert a <code><a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Result">Result</a></code> value to an <code><a href="../base-4.6.0.1/Data-Either.html#t:Either">Either</a></code> value. A <code><a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#v:Partial">Partial</a></code>
 result is treated as failure.
</p></div></div><h1 id="g:7">Combinators
</h1><div class="top"><p class="src">module <a href="../attoparsec-0.11.2.1/Data-Attoparsec-Combinator.html">Data.Attoparsec.Combinator</a></p></div><h1 id="g:8">Parsing individual bytes
</h1><div class="top"><p class="src"><a name="v:word8" class="def">word8</a> :: <a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a></p><div class="doc"><p>Match a specific byte.
</p></div></div><div class="top"><p class="src"><a name="v:anyWord8" class="def">anyWord8</a> :: <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a></p><div class="doc"><p>Match any byte.
</p></div></div><div class="top"><p class="src"><a name="v:notWord8" class="def">notWord8</a> :: <a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a></p><div class="doc"><p>Match any byte except the given one.
</p></div></div><div class="top"><p class="src"><a name="v:satisfy" class="def">satisfy</a> :: (<a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.6.0.1/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a></p><div class="doc"><p>The parser <code>satisfy p</code> succeeds for any byte for which the
 predicate <code>p</code> returns <code><a href="../base-4.6.0.1/Data-Bool.html#v:True">True</a></code>. Returns the byte that is actually
 parsed.
</p><pre>digit = satisfy isDigit
    where isDigit w = w &gt;= 48 &amp;&amp; w &lt;= 57
</pre></div></div><div class="top"><p class="src"><a name="v:satisfyWith" class="def">satisfyWith</a> ::  (<a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a> -&gt; a) -&gt; (a -&gt; <a href="../base-4.6.0.1/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> a</p><div class="doc"><p>The parser <code>satisfyWith f p</code> transforms a byte, and succeeds if
 the predicate <code>p</code> returns <code><a href="../base-4.6.0.1/Data-Bool.html#v:True">True</a></code> on the transformed value. The
 parser returns the transformed byte that was parsed.
</p></div></div><div class="top"><p class="src"><a name="v:skip" class="def">skip</a> :: (<a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.6.0.1/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> ()</p><div class="doc"><p>The parser <code>skip p</code> succeeds for any byte for which the predicate
 <code>p</code> returns <code><a href="../base-4.6.0.1/Data-Bool.html#v:True">True</a></code>.
</p><pre>skipDigit = skip isDigit
    where isDigit w = w &gt;= 48 &amp;&amp; w &lt;= 57
</pre></div></div><h2 id="g:9">Lookahead
</h2><div class="top"><p class="src"><a name="v:peekWord8" class="def">peekWord8</a> :: <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> (<a href="../base-4.6.0.1/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a>)</p><div class="doc"><p>Match any byte, to perform lookahead. Returns <code><a href="../base-4.6.0.1/Data-Maybe.html#v:Nothing">Nothing</a></code> if end of
 input has been reached. Does not consume any input.
</p><p><em>Note</em>: Because this parser does not fail, do not use it with
 combinators such as <code>many</code>, because such parsers loop until a
 failure occurs.  Careless use will thus result in an infinite loop.
</p></div></div><div class="top"><p class="src"><a name="v:peekWord8-39-" class="def">peekWord8'</a> :: <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a></p><div class="doc"><p>Match any byte, to perform lookahead.  Does not consume any
 input, but will fail if end of input has been reached.
</p></div></div><h2 id="g:10">Byte classes
</h2><div class="top"><p class="src"><a name="v:inClass" class="def">inClass</a> :: <a href="../base-4.6.0.1/Data-String.html#t:String">String</a> -&gt; <a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.6.0.1/Data-Bool.html#t:Bool">Bool</a></p><div class="doc"><p>Match any byte in a set.
</p><pre>vowel = inClass &quot;aeiou&quot;
</pre><p>Range notation is supported.
</p><pre>halfAlphabet = inClass &quot;a-nA-N&quot;
</pre><p>To add a literal <code>'-'</code> to a set, place it at the beginning or end
 of the string.
</p></div></div><div class="top"><p class="src"><a name="v:notInClass" class="def">notInClass</a> :: <a href="../base-4.6.0.1/Data-String.html#t:String">String</a> -&gt; <a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.6.0.1/Data-Bool.html#t:Bool">Bool</a></p><div class="doc"><p>Match any byte not in a set.
</p></div></div><h1 id="g:11">Efficient string handling
</h1><div class="top"><p class="src"><a name="v:string" class="def">string</a> :: <a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a></p><div class="doc"><p><code>string s</code> parses a sequence of bytes that identically match
 <code>s</code>. Returns the parsed string (i.e. <code>s</code>).  This parser consumes no
 input if it fails (even if a partial match).
</p><p><em>Note</em>: The behaviour of this parser is different to that of the
 similarly-named parser in Parsec, as this one is all-or-nothing.
 To illustrate the difference, the following parser will fail under
 Parsec given an input of <code>&quot;for&quot;</code>:
</p><pre>string &quot;foo&quot; &lt;|&gt; string &quot;for&quot;
</pre><p>The reason for its failure is that the first branch is a
 partial match, and will consume the letters <code>'f'</code> and <code>'o'</code>
 before failing.  In Attoparsec, the above parser will <em>succeed</em> on
 that input, because the failed first branch will consume nothing.
</p></div></div><div class="top"><p class="src"><a name="v:skipWhile" class="def">skipWhile</a> :: (<a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.6.0.1/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> ()</p><div class="doc"><p>Skip past input for as long as the predicate returns <code><a href="../base-4.6.0.1/Data-Bool.html#v:True">True</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:take" class="def">take</a> :: <a href="../base-4.6.0.1/Data-Int.html#t:Int">Int</a> -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a></p><div class="doc"><p>Consume exactly <code>n</code> bytes of input.
</p></div></div><div class="top"><p class="src"><a name="v:scan" class="def">scan</a> ::  s -&gt; (s -&gt; <a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.6.0.1/Data-Maybe.html#t:Maybe">Maybe</a> s) -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a></p><div class="doc"><p>A stateful scanner.  The predicate consumes and transforms a
 state argument, and each transformed state is passed to successive
 invocations of the predicate on each byte of the input until one
 returns <code><a href="../base-4.6.0.1/Data-Maybe.html#v:Nothing">Nothing</a></code> or the input ends.
</p><p>This parser does not fail.  It will return an empty string if the
 predicate returns <code><a href="../base-4.6.0.1/Data-Maybe.html#v:Nothing">Nothing</a></code> on the first byte of input.
</p><p><em>Note</em>: Because this parser does not fail, do not use it with
 combinators such as <code>many</code>, because such parsers loop until a
 failure occurs.  Careless use will thus result in an infinite loop.
</p></div></div><div class="top"><p class="src"><a name="v:takeWhile" class="def">takeWhile</a> :: (<a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.6.0.1/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a></p><div class="doc"><p>Consume input as long as the predicate returns <code><a href="../base-4.6.0.1/Data-Bool.html#v:True">True</a></code>, and return
 the consumed input.
</p><p>This parser does not fail.  It will return an empty string if the
 predicate returns <code><a href="../base-4.6.0.1/Data-Bool.html#v:False">False</a></code> on the first byte of input.
</p><p><em>Note</em>: Because this parser does not fail, do not use it with
 combinators such as <code>many</code>, because such parsers loop until a
 failure occurs.  Careless use will thus result in an infinite loop.
</p></div></div><div class="top"><p class="src"><a name="v:takeWhile1" class="def">takeWhile1</a> :: (<a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.6.0.1/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a></p><div class="doc"><p>Consume input as long as the predicate returns <code><a href="../base-4.6.0.1/Data-Bool.html#v:True">True</a></code>, and return
 the consumed input.
</p><p>This parser requires the predicate to succeed on at least one byte
 of input: it will fail if the predicate never returns <code><a href="../base-4.6.0.1/Data-Bool.html#v:True">True</a></code> or if
 there is no input left.
</p></div></div><div class="top"><p class="src"><a name="v:takeTill" class="def">takeTill</a> :: (<a href="../base-4.6.0.1/Data-Word.html#t:Word8">Word8</a> -&gt; <a href="../base-4.6.0.1/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a></p><div class="doc"><p>Consume input as long as the predicate returns <code><a href="../base-4.6.0.1/Data-Bool.html#v:False">False</a></code>
 (i.e. until it returns <code><a href="../base-4.6.0.1/Data-Bool.html#v:True">True</a></code>), and return the consumed input.
</p><p>This parser does not fail.  It will return an empty string if the
 predicate returns <code><a href="../base-4.6.0.1/Data-Bool.html#v:True">True</a></code> on the first byte of input.
</p><p><em>Note</em>: Because this parser does not fail, do not use it with
 combinators such as <code>many</code>, because such parsers loop until a
 failure occurs.  Careless use will thus result in an infinite loop.
</p></div></div><h2 id="g:12">Consume all remaining input
</h2><div class="top"><p class="src"><a name="v:takeByteString" class="def">takeByteString</a> :: <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../bytestring-0.10.0.2/Data-ByteString.html#t:ByteString">ByteString</a></p><div class="doc"><p>Consume all remaining input and return it as a single string.
</p></div></div><div class="top"><p class="src"><a name="v:takeLazyByteString" class="def">takeLazyByteString</a> :: <a href="../attoparsec-0.11.2.1/Data-Attoparsec-ByteString.html#t:Parser">Parser</a> <a href="../bytestring-0.10.0.2/Data-ByteString-Lazy.html#t:ByteString">ByteString</a></p><div class="doc"><p>Consume all remaining input and return it as a single string.
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2.1</p></div></body></html>